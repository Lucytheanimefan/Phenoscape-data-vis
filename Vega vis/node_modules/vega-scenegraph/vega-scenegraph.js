(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.vg || (g.vg = {})).scene = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
// Matches absolute URLs with optional protocol
//   https://...    file://...    //...
var protocol_re = /^([A-Za-z]+:)?\/\//;

// Special treatment in node.js for the file: protocol
var fileProtocol = 'file://';

// Validate and cleanup URL to ensure that it is allowed to be accessed
// Returns cleaned up URL, or false if access is not allowed
function sanitizeUrl(opt) {
  var url = opt.url;
  if (!url && opt.file) { return fileProtocol + opt.file; }

  // In case this is a relative url (has no host), prepend opt.baseURL
  if (opt.baseURL && !protocol_re.test(url)) {
    if (!startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {
      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url
    }
    url = opt.baseURL + url;
  }
  // relative protocol, starts with '//'
  if (!load.useXHR && startsWith(url, '//')) {
    url = (opt.defaultProtocol || 'http') + ':' + url;
  }
  // If opt.domainWhiteList is set, only allows url, whose hostname
  // * Is the same as the origin (window.location.hostname)
  // * Equals one of the values in the whitelist
  // * Is a proper subdomain of one of the values in the whitelist
  if (opt.domainWhiteList) {
    var domain, origin;
    if (load.useXHR) {
      var a = document.createElement('a');
      a.href = url;
      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript
      // IE doesn't populate all link properties when setting .href with a relative URL,
      // however .href will return an absolute URL which then can be used on itself
      // to populate these additional fields.
      if (a.host === '') {
        a.href = a.href;
      }
      domain = a.hostname.toLowerCase();
      origin = window.location.hostname;
    } else {
      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5
      var parts = require('url').parse(url);
      domain = parts.hostname;
      origin = null;
    }

    if (origin !== domain) {
      var whiteListed = opt.domainWhiteList.some(function(d) {
        var idx = domain.length - d.length;
        return d === domain ||
          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);
      });
      if (!whiteListed) {
        throw 'URL is not whitelisted: ' + url;
      }
    }
  }
  return url;
}

function load(opt, callback) {
  var error = callback || function(e) { throw e; }, url;

  try {
    url = load.sanitizeUrl(opt); // enable override
  } catch (err) {
    error(err);
    return;
  }

  if (!url) {
    error('Invalid URL: ' + opt.url);
  } else if (load.useXHR) {
    // on client, use xhr
    return xhr(url, callback);
  } else if (startsWith(url, fileProtocol)) {
    // on server, if url starts with 'file://', strip it and load from file
    return file(url.slice(fileProtocol.length), callback);
  } else if (url.indexOf('://') < 0) { // TODO better protocol check?
    // on server, if no protocol assume file
    return file(url, callback);
  } else {
    // for regular URLs on server
    return http(url, callback);
  }
}

function xhrHasResponse(request) {
  var type = request.responseType;
  return type && type !== 'text' ?
    request.response : // null on error
    request.responseText; // '' on error
}

function xhr(url, callback) {
  var async = !!callback;
  var request = new XMLHttpRequest();
  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)
  if (this.XDomainRequest &&
      !('withCredentials' in request) &&
      /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();

  function respond() {
    var status = request.status;
    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
      callback(null, request.responseText);
    } else {
      callback(request, null);
    }
  }

  if (async) {
    if ('onload' in request) {
      request.onload = request.onerror = respond;
    } else {
      request.onreadystatechange = function() {
        if (request.readyState > 3) respond();
      };
    }
  }
  
  request.open('GET', url, async);
  request.send();
  
  if (!async && xhrHasResponse(request)) {
    return request.responseText;
  }
}

function file(filename, callback) {
  var fs = require('fs');
  if (!callback) {
    return fs.readFileSync(filename, 'utf8');
  }
  fs.readFile(filename, callback);
}

function http(url, callback) {
  if (!callback) {
    return require('sync-request')('GET', url).getBody();
  }
  
  var options = {url: url, encoding: null, gzip: true};
  require('request')(options, function(error, response, body) {
    if (!error && response.statusCode === 200) {
      callback(null, body);
    } else {
      error = error ||
        'Load failed with response code ' + response.statusCode + '.';
      callback(error, null);
    }
  });
}

function startsWith(string, searchString) {
  return string == null ? false : string.lastIndexOf(searchString, 0) === 0;
}

load.sanitizeUrl = sanitizeUrl;

load.useXHR = (typeof XMLHttpRequest !== 'undefined');

module.exports = load;

},{"fs":1,"request":1,"sync-request":1,"url":1}],3:[function(require,module,exports){
module.exports = {
  path:       require('./path'),
  render:     require('./render'),
  Item:       require('./util/Item'),
  bound:      require('./util/bound'),
  Bounds:     require('./util/Bounds'),
  canvas:     require('./util/canvas'),
  Gradient:   require('./util/Gradient'),
  toJSON:     require('./util/scene').toJSON,
  fromJSON:   require('./util/scene').fromJSON
};
},{"./path":5,"./render":25,"./util/Bounds":31,"./util/Gradient":33,"./util/Item":35,"./util/bound":36,"./util/canvas":37,"./util/scene":39}],4:[function(require,module,exports){
var segmentCache = {},
    bezierCache = {},
    join = [].join;

// Copied from Inkscape svgtopdf, thanks!
function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  var key = join.call(arguments);
  if (segmentCache[key]) {
    return segmentCache[key];
  }

  var th = rotateX * (Math.PI/180);
  var sin_th = Math.sin(th);
  var cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
  var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  var pl = (px*px) / (rx*rx) + (py*py) / (ry*ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }

  var a00 = cos_th / rx;
  var a01 = sin_th / rx;
  var a10 = (-sin_th) / ry;
  var a11 = (cos_th) / ry;
  var x0 = a00 * ox + a01 * oy;
  var y0 = a10 * ox + a11 * oy;
  var x1 = a00 * x + a01 * y;
  var y1 = a10 * x + a11 * y;

  var d = (x1-x0) * (x1-x0) + (y1-y0) * (y1-y0);
  var sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0) sfactor_sq = 0;
  var sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large) sfactor = -sfactor;
  var xc = 0.5 * (x0 + x1) - sfactor * (y1-y0);
  var yc = 0.5 * (y0 + y1) + sfactor * (x1-x0);

  var th0 = Math.atan2(y0-yc, x0-xc);
  var th1 = Math.atan2(y1-yc, x1-xc);

  var th_arc = th1-th0;
  if (th_arc < 0 && sweep === 1){
    th_arc += 2 * Math.PI;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= 2 * Math.PI;
  }

  var segs = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));
  var result = [];
  for (var i=0; i<segs; ++i) {
    var th2 = th0 + i * th_arc / segs;
    var th3 = th0 + (i+1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }

  return (segmentCache[key] = result);
}

function bezier(params) {
  var key = join.call(params);
  if (bezierCache[key]) {
    return bezierCache[key];
  }
  
  var cx = params[0],
      cy = params[1],
      th0 = params[2],
      th1 = params[3],
      rx = params[4],
      ry = params[5],
      sin_th = params[6],
      cos_th = params[7];

  var a00 = cos_th * rx;
  var a01 = -sin_th * ry;
  var a10 = sin_th * rx;
  var a11 = cos_th * ry;

  var cos_th0 = Math.cos(th0);
  var sin_th0 = Math.sin(th0);
  var cos_th1 = Math.cos(th1);
  var sin_th1 = Math.sin(th1);

  var th_half = 0.5 * (th1 - th0);
  var sin_th_h2 = Math.sin(th_half * 0.5);
  var t = (8/3) * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  var x1 = cx + cos_th0 - t * sin_th0;
  var y1 = cy + sin_th0 + t * cos_th0;
  var x3 = cx + cos_th1;
  var y3 = cy + sin_th1;
  var x2 = x3 + t * sin_th1;
  var y2 = y3 - t * cos_th1;

  return (bezierCache[key] = [
    a00 * x1 + a01 * y1,  a10 * x1 + a11 * y1,
    a00 * x2 + a01 * y2,  a10 * x2 + a11 * y2,
    a00 * x3 + a01 * y3,  a10 * x3 + a11 * y3
  ]);
}

module.exports = {
  segments: segments,
  bezier: bezier,
  cache: {
    segments: segmentCache,
    bezier: bezierCache
  }
};

},{}],5:[function(require,module,exports){
module.exports = {
  parse:  require('./parse'),
  render: require('./render')
};

},{"./parse":6,"./render":7}],6:[function(require,module,exports){
// Path parsing and rendering code adapted from fabric.js -- Thanks!
var cmdlen = { m:2, l:2, h:1, v:1, c:6, s:4, q:4, t:2, a:7 },
    regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\d)([-+])/g, /\s|,|###/];

module.exports = function(pathstr) {
  var result = [],
      path,
      curr,
      chunks,
      parsed, param,
      cmd, len, i, j, n, m;

  // First, break path into command sequence
  path = pathstr
    .slice()
    .replace(regexp[0], '###$1')
    .split(regexp[1])
    .slice(1);

  // Next, parse each command in turn
  for (i=0, n=path.length; i<n; ++i) {
    curr = path[i];
    chunks = curr
      .slice(1)
      .trim()
      .replace(regexp[2],'$1###$2')
      .split(regexp[3]);
    cmd = curr.charAt(0);

    parsed = [cmd];
    for (j=0, m=chunks.length; j<m; ++j) {
      if ((param = +chunks[j]) === param) { // not NaN
        parsed.push(param);
      }
    }

    len = cmdlen[cmd.toLowerCase()];
    if (parsed.length-1 > len) {
      for (j=1, m=parsed.length; j<m; j+=len) {
        result.push([cmd].concat(parsed.slice(j, j+len)));
      }
    }
    else {
      result.push(parsed);
    }
  }

  return result;
};

},{}],7:[function(require,module,exports){
var arc = require('./arc');

module.exports = function(g, path, l, t) {
  var current, // current instruction
      previous = null,
      x = 0, // current x
      y = 0, // current y
      controlX = 0, // current control point x
      controlY = 0, // current control point y
      tempX,
      tempY,
      tempControlX,
      tempControlY;

  if (l == null) l = 0;
  if (t == null) t = 0;

  g.beginPath();

  for (var i=0, len=path.length; i<len; ++i) {
    current = path[i];

    switch (current[0]) { // first letter

      case 'l': // lineto, relative
        x += current[1];
        y += current[2];
        g.lineTo(x + l, y + t);
        break;

      case 'L': // lineto, absolute
        x = current[1];
        y = current[2];
        g.lineTo(x + l, y + t);
        break;

      case 'h': // horizontal lineto, relative
        x += current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'H': // horizontal lineto, absolute
        x = current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'v': // vertical lineto, relative
        y += current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'V': // verical lineto, absolute
        y = current[1];
        g.lineTo(x + l, y + t);
        break;

      case 'm': // moveTo, relative
        x += current[1];
        y += current[2];
        g.moveTo(x + l, y + t);
        break;

      case 'M': // moveTo, absolute
        x = current[1];
        y = current[2];
        g.moveTo(x + l, y + t);
        break;

      case 'c': // bezierCurveTo, relative
        tempX = x + current[5];
        tempY = y + current[6];
        controlX = x + current[3];
        controlY = y + current[4];
        g.bezierCurveTo(
          x + current[1] + l, // x1
          y + current[2] + t, // y1
          controlX + l, // x2
          controlY + t, // y2
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        break;

      case 'C': // bezierCurveTo, absolute
        x = current[5];
        y = current[6];
        controlX = current[3];
        controlY = current[4];
        g.bezierCurveTo(
          current[1] + l,
          current[2] + t,
          controlX + l,
          controlY + t,
          x + l,
          y + t
        );
        break;

      case 's': // shorthand cubic bezierCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4];
        // calculate reflection of previous control points
        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        g.bezierCurveTo(
          controlX + l,
          controlY + t,
          x + current[1] + l,
          y + current[2] + t,
          tempX + l,
          tempY + t
        );

        // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.
        controlX = x + current[1];
        controlY = y + current[2];

        x = tempX;
        y = tempY;
        break;

      case 'S': // shorthand cubic bezierCurveTo, absolute
        tempX = current[3];
        tempY = current[4];
        // calculate reflection of previous control points
        controlX = 2*x - controlX;
        controlY = 2*y - controlY;
        g.bezierCurveTo(
          controlX + l,
          controlY + t,
          current[1] + l,
          current[2] + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.
        controlX = current[1];
        controlY = current[2];

        break;

      case 'q': // quadraticCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4];

        controlX = x + current[1];
        controlY = y + current[2];

        g.quadraticCurveTo(
          controlX + l,
          controlY + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        break;

      case 'Q': // quadraticCurveTo, absolute
        tempX = current[3];
        tempY = current[4];

        g.quadraticCurveTo(
          current[1] + l,
          current[2] + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        controlX = current[1];
        controlY = current[2];
        break;

      case 't': // shorthand quadraticCurveTo, relative

        // transform to absolute x,y
        tempX = x + current[1];
        tempY = y + current[2];

        if (previous[0].match(/[QqTt]/) === null) {
          // If there is no previous command or if the previous command was not a Q, q, T or t,
          // assume the control point is coincident with the current point
          controlX = x;
          controlY = y;
        }
        else if (previous[0] === 't') {
          // calculate reflection of previous control points for t
          controlX = 2 * x - tempControlX;
          controlY = 2 * y - tempControlY;
        }
        else if (previous[0] === 'q') {
          // calculate reflection of previous control points for q
          controlX = 2 * x - controlX;
          controlY = 2 * y - controlY;
        }

        tempControlX = controlX;
        tempControlY = controlY;

        g.quadraticCurveTo(
          controlX + l,
          controlY + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        controlX = x + current[1];
        controlY = y + current[2];
        break;

      case 'T':
        tempX = current[1];
        tempY = current[2];

        // calculate reflection of previous control points
        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        g.quadraticCurveTo(
          controlX + l,
          controlY + t,
          tempX + l,
          tempY + t
        );
        x = tempX;
        y = tempY;
        break;

      case 'a':
        drawArc(g, x + l, y + t, [
          current[1],
          current[2],
          current[3],
          current[4],
          current[5],
          current[6] + x + l,
          current[7] + y + t
        ]);
        x += current[6];
        y += current[7];
        break;

      case 'A':
        drawArc(g, x + l, y + t, [
          current[1],
          current[2],
          current[3],
          current[4],
          current[5],
          current[6] + l,
          current[7] + t
        ]);
        x = current[6];
        y = current[7];
        break;

      case 'z':
      case 'Z':
        g.closePath();
        break;
    }
    previous = current;
  }
};

function drawArc(g, x, y, coords) {
  var seg = arc.segments(
    coords[5], // end x
    coords[6], // end y
    coords[0], // radius x
    coords[1], // radius y
    coords[3], // large flag
    coords[4], // sweep flag
    coords[2], // rotation
    x, y
  );
  for (var i=0; i<seg.length; ++i) {
    var bez = arc.bezier(seg[i]);
    g.bezierCurveTo.apply(g, bez);
  }
}

},{"./arc":4}],8:[function(require,module,exports){
function Handler() {
  this._active = null;
  this._handlers = {};
}

var prototype = Handler.prototype;

prototype.initialize = function(el, pad, obj) {
  this._el = el;
  this._obj = obj || null;
  return this.padding(pad);
};

prototype.element = function() {
  return this._el;
};

prototype.padding = function(pad) {
  this._padding = pad || {top:0, left:0, bottom:0, right:0};
  return this;
};

prototype.scene = function(scene) {
  if (!arguments.length) return this._scene;
  this._scene = scene;
  return this;
};

// add an event handler
// subclasses should override
prototype.on = function(/*type, handler*/) {};

// remove an event handler
// subclasses should override
prototype.off = function(/*type, handler*/) {};

// return an array with all registered event handlers
prototype.handlers = function() {
  var h = this._handlers, a = [], k;
  for (k in h) { a.push.apply(a, h[k]); }
  return a;
};

prototype.eventName = function(name) {
  var i = name.indexOf('.');
  return i < 0 ? name : name.slice(0,i);
};

module.exports = Handler;
},{}],9:[function(require,module,exports){
function Renderer() {
  this._el = null;
  this._bgcolor = null;
}

var prototype = Renderer.prototype;

prototype.initialize = function(el, width, height, padding) {
  this._el = el;
  return this.resize(width, height, padding);
};

// Returns the parent container element for a visualization
prototype.element = function() {
  return this._el;
};

// Returns the scene element (e.g., canvas or SVG) of the visualization
// Subclasses must override if the first child is not the scene element
prototype.scene = function() {
  return this._el && this._el.firstChild;
};

prototype.background = function(bgcolor) {
  if (arguments.length === 0) return this._bgcolor;
  this._bgcolor = bgcolor;
  return this;
};

prototype.resize = function(width, height, padding) {
  this._width = width;
  this._height = height;
  this._padding = padding || {top:0, left:0, bottom:0, right:0};
  return this;
};

prototype.render = function(/*scene, items*/) {
  return this;
};

module.exports = Renderer;
},{}],10:[function(require,module,exports){
var DOM = require('../../util/dom'),
    Handler = require('../Handler'),
    marks = require('./marks');

function CanvasHandler() {
  Handler.call(this);
  this._down = null;
  this._touch = null;
  this._first = true;
}

var base = Handler.prototype;
var prototype = (CanvasHandler.prototype = Object.create(base));
prototype.constructor = CanvasHandler;

prototype.initialize = function(el, pad, obj) {
  // add event listeners
  var canvas = this._canvas = DOM.find(el, 'canvas');
  if (canvas) {
    var that = this;
    this.events.forEach(function(type) {
      canvas.addEventListener(type, function(evt) {
        if (prototype[type]) {
          prototype[type].call(that, evt);
        } else {
          that.fire(type, evt);
        }
      });
    });
  }

  return base.initialize.call(this, el, pad, obj);
};

prototype.canvas = function() {
  return this._canvas;
};

// retrieve the current canvas context
prototype.context = function() {
  return this._canvas.getContext('2d');
};

// supported events
prototype.events = [
  'keydown',
  'keypress',
  'keyup',
  'dragenter',
  'dragleave',
  'dragover',
  'mousedown',
  'mouseup',
  'mousemove',
  'mouseout',
  'mouseover',
  'click',
  'dblclick',
  'wheel',
  'mousewheel',
  'touchstart',
  'touchmove',
  'touchend'
];

// to keep firefox happy
prototype.DOMMouseScroll = function(evt) {
  this.fire('mousewheel', evt);
};

function move(moveEvent, overEvent, outEvent) {
  return function(evt) {
    var a = this._active,
        p = this.pickEvent(evt);

    if (p === a) {
      // active item and picked item are the same
      this.fire(moveEvent, evt); // fire move
    } else {
      // active item and picked item are different
      this.fire(outEvent, evt);  // fire out for prior active item
      this._active = p;            // set new active item
      this.fire(overEvent, evt); // fire over for new active item
      this.fire(moveEvent, evt); // fire move for new active item
    }
  };
}

function inactive(type) {
  return function(evt) {
    this.fire(type, evt);
    this._active = null;
  };
}

prototype.mousemove = move('mousemove', 'mouseover', 'mouseout');
prototype.dragover  = move('dragover', 'dragenter', 'dragleave');

prototype.mouseout  = inactive('mouseout');
prototype.dragleave = inactive('dragleave');

prototype.mousedown = function(evt) {
  this._down = this._active;
  this.fire('mousedown', evt);
};

prototype.click = function(evt) {
  if (this._down === this._active) {
    this.fire('click', evt);
    this._down = null;
  }
};

prototype.touchstart = function(evt) {
  this._touch = this.pickEvent(evt.changedTouches[0]);

  if (this._first) {
    this._active = this._touch;
    this._first = false;
  }

  this.fire('touchstart', evt, true);
};

prototype.touchmove = function(evt) {
  this.fire('touchmove', evt, true);
};

prototype.touchend = function(evt) {
  this.fire('touchend', evt, true);
  this._touch = null;
};

// fire an event
prototype.fire = function(type, evt, touch) {
  var a = touch ? this._touch : this._active,
      h = this._handlers[type], i, len;
  if (h) {
    evt.vegaType = type;
    for (i=0, len=h.length; i<len; ++i) {
      h[i].handler.call(this._obj, evt, a);
    }
  }
};

// add an event handler
prototype.on = function(type, handler) {
  var name = this.eventName(type),
      h = this._handlers;
  (h[name] || (h[name] = [])).push({
    type: type,
    handler: handler
  });
  return this;
};

// remove an event handler
prototype.off = function(type, handler) {
  var name = this.eventName(type),
      h = this._handlers[name], i;
  if (!h) return;
  for (i=h.length; --i>=0;) {
    if (h[i].type !== type) continue;
    if (!handler || h[i].handler === handler) h.splice(i, 1);
  }
  return this;
};

prototype.pickEvent = function(evt) {
  var rect = this._canvas.getBoundingClientRect(),
      pad = this._padding, x, y;
  return this.pick(this._scene,
    x = (evt.clientX - rect.left),
    y = (evt.clientY - rect.top),
    x - pad.left, y - pad.top);
};

// find the scenegraph item at the current mouse position
// x, y -- the absolute x, y mouse coordinates on the canvas element
// gx, gy -- the relative coordinates within the current group
prototype.pick = function(scene, x, y, gx, gy) {
  var g = this.context(),
      mark = marks[scene.marktype];
  return mark.pick.call(this, g, scene, x, y, gx, gy);
};

module.exports = CanvasHandler;

},{"../../util/dom":38,"../Handler":8,"./marks":17}],11:[function(require,module,exports){
var DOM = require('../../util/dom'),
    Bounds = require('../../util/Bounds'),
    ImageLoader = require('../../util/ImageLoader'),
    Canvas = require('../../util/canvas'),
    Renderer = require('../Renderer'),
    marks = require('./marks');

function CanvasRenderer(loadConfig) {
  Renderer.call(this);
  this._loader = new ImageLoader(loadConfig);
}

CanvasRenderer.RETINA = true;

var base = Renderer.prototype;
var prototype = (CanvasRenderer.prototype = Object.create(base));
prototype.constructor = CanvasRenderer;

prototype.initialize = function(el, width, height, padding) {
  this._canvas = Canvas.instance(width, height);
  if (el) {
    DOM.clear(el, 0).appendChild(this._canvas);
    this._canvas.setAttribute('class', 'marks');
  }
  return base.initialize.call(this, el, width, height, padding);
};

prototype.resize = function(width, height, padding) {
  base.resize.call(this, width, height, padding);
  Canvas.resize(this._canvas, this._width, this._height,
    this._padding, CanvasRenderer.RETINA);
  return this;
};

prototype.canvas = function() {
  return this._canvas;
};

prototype.context = function() {
  return this._canvas ? this._canvas.getContext('2d') : null;
};

prototype.pendingImages = function() {
  return this._loader.pending();
};

function clipToBounds(g, items) {
  if (!items) return null;

  var b = new Bounds(), i, n, item, mark, group;
  for (i=0, n=items.length; i<n; ++i) {
    item = items[i];
    mark = item.mark;
    group = mark.group;
    item = marks[mark.marktype].nested ? mark : item;
    b.union(translate(item.bounds, group));
    if (item['bounds:prev']) {
      b.union(translate(item['bounds:prev'], group));
    }
  }
  b.round();

  g.beginPath();
  g.rect(b.x1, b.y1, b.width(), b.height());
  g.clip();

  return b;
}

function translate(bounds, group) {
  if (group == null) return bounds;
  var b = bounds.clone();
  for (; group != null; group = group.mark.group) {
    b.translate(group.x || 0, group.y || 0);
  }
  return b;
}

prototype.render = function(scene, items) {
  var g = this.context(),
      p = this._padding,
      w = this._width + p.left + p.right,
      h = this._height + p.top + p.bottom,
      b;

  // setup
  this._scene = scene; // cache scene for async redraw
  g.save();
  b = clipToBounds(g, items);
  this.clear(-p.left, -p.top, w, h);

  // render
  this.draw(g, scene, b);
  
  // takedown
  g.restore();
  this._scene = null; // clear scene cache

  return this;
};

prototype.draw = function(ctx, scene, bounds) {
  var mark = marks[scene.marktype];
  mark.draw.call(this, ctx, scene, bounds);
};

prototype.clear = function(x, y, w, h) {
  var g = this.context();
  g.clearRect(x, y, w, h);
  if (this._bgcolor != null) {
    g.fillStyle = this._bgcolor;
    g.fillRect(x, y, w, h); 
  }
};

prototype.loadImage = function(uri) {
  var renderer = this,
      scene = this._scene;
  return this._loader.loadImage(uri, function() {
    renderer.renderAsync(scene);
  });
};

prototype.renderAsync = function(scene) {
  // TODO make safe for multiple scene rendering?
  var renderer = this;
  if (renderer._async_id) {
    clearTimeout(renderer._async_id);
  }
  renderer._async_id = setTimeout(function() {
    renderer.render(scene);
    delete renderer._async_id;
  }, 10);
};

module.exports = CanvasRenderer;

},{"../../util/Bounds":31,"../../util/ImageLoader":34,"../../util/canvas":37,"../../util/dom":38,"../Renderer":9,"./marks":17}],12:[function(require,module,exports){
module.exports = {
  Handler:  require('./CanvasHandler'),
  Renderer: require('./CanvasRenderer')
};
},{"./CanvasHandler":10,"./CanvasRenderer":11}],13:[function(require,module,exports){
var util = require('./util');
var halfpi = Math.PI / 2;

function path(g, o) {
  var x = o.x || 0,
      y = o.y || 0,
      ir = o.innerRadius || 0,
      or = o.outerRadius || 0,
      sa = (o.startAngle || 0) - halfpi,
      ea = (o.endAngle || 0) - halfpi;
  g.beginPath();
  if (ir === 0) g.moveTo(x, y);
  else g.arc(x, y, ir, sa, ea, 0);
  g.arc(x, y, or, ea, sa, 1);
  g.closePath();
}

module.exports = {
  draw: util.drawAll(path),
  pick: util.pickPath(path)
};
},{"./util":24}],14:[function(require,module,exports){
var util = require('./util'),
    parse = require('../../../path/parse'),
    render = require('../../../path/render'),
    areaPath = require('../../../util/svg').path.area;

function path(g, items) {
  var o = items[0],
      p = o.pathCache || (o.pathCache = parse(areaPath(items)));
  render(g, p);
}

function pick(g, scene, x, y, gx, gy) {
  var items = scene.items,
      b = scene.bounds;

  if (!items || !items.length || b && !b.contains(gx, gy)) {
    return null;
  }

  if (g.pixelratio != null && g.pixelratio !== 1) {
    x *= g.pixelratio;
    y *= g.pixelratio;
  }
  return hit(g, items, x, y) ? items[0] : null;
}

var hit = util.testPath(path);

module.exports = {
  draw: util.drawOne(path),
  pick: pick,
  nested: true
};

},{"../../../path/parse":6,"../../../path/render":7,"../../../util/svg":40,"./util":24}],15:[function(require,module,exports){
var util = require('./util'),
    EMPTY = [];

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var groups = scene.items,
      renderer = this,
      group, items, axes, legends, gx, gy, w, h, opac, i, n, j, m;

  for (i=0, n=groups.length; i<n; ++i) {
    group = groups[i];
    axes = group.axisItems || EMPTY;
    items = group.items || EMPTY;
    legends = group.legendItems || EMPTY;
    gx = group.x || 0;
    gy = group.y || 0;
    w = group.width || 0;
    h = group.height || 0;

    // draw group background
    if (group.stroke || group.fill) {
      opac = group.opacity == null ? 1 : group.opacity;
      if (opac > 0) {
        if (group.fill && util.fill(g, group, opac)) {
          g.fillRect(gx, gy, w, h);
        }
        if (group.stroke && util.stroke(g, group, opac)) {
          g.strokeRect(gx, gy, w, h);
        }
      }
    }

    // setup graphics context
    g.save();
    g.translate(gx, gy);
    if (group.clip) {
      g.beginPath();
      g.rect(0, 0, w, h);
      g.clip();
    }
    if (bounds) bounds.translate(-gx, -gy);

    // draw group contents
    for (j=0, m=axes.length; j<m; ++j) {
      if (axes[j].layer === 'back') {
        renderer.draw(g, axes[j], bounds);
      }
    }
    for (j=0, m=items.length; j<m; ++j) {
      renderer.draw(g, items[j], bounds);
    }
    for (j=0, m=axes.length; j<m; ++j) {
      if (axes[j].layer !== 'back') {
        renderer.draw(g, axes[j], bounds);
      }
    }
    for (j=0, m=legends.length; j<m; ++j) {
      renderer.draw(g, legends[j], bounds);
    }

    // restore graphics context
    if (bounds) bounds.translate(gx, gy);
    g.restore();
  }    
}

function pick(g, scene, x, y, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy)) {
    return null;
  }

  var groups = scene.items || EMPTY, subscene,
      group, axes, items, legends, hits, dx, dy, i, j, b;

  for (i=groups.length; --i>=0;) {
    group = groups[i];

    // first hit test against bounding box
    // if a group is clipped, that should be handled by the bounds check.
    b = group.bounds;
    if (b && !b.contains(gx, gy)) continue;

    // passed bounds check, so test sub-groups
    axes = group.axisItems || EMPTY;
    items = group.items || EMPTY;
    legends = group.legendItems || EMPTY;
    dx = (group.x || 0);
    dy = (group.y || 0);

    g.save();
    g.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;
    for (j=legends.length; --j>=0;) {
      subscene = legends[j];
      if (subscene.interactive !== false) {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    for (j=axes.length; --j>=0;) {
      subscene = axes[j];
      if (subscene.interactive !== false && subscene.layer !== 'back') {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    for (j=items.length; --j>=0;) {
      subscene = items[j];
      if (subscene.interactive !== false) {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    for (j=axes.length; --j>=0;) {
      subscene = axes[j];
      if (subscene.interative !== false && subscene.layer === 'back') {
        hits = this.pick(subscene, x, y, dx, dy);
        if (hits) { g.restore(); return hits; }
      }
    }
    g.restore();

    if (scene.interactive !== false && (group.fill || group.stroke) &&
        dx >= 0 && dx <= group.width && dy >= 0 && dy <= group.height) {
      return group;
    }
  }

  return null;
}

module.exports = {
  draw: draw,
  pick: pick
};

},{"./util":24}],16:[function(require,module,exports){
var util = require('./util');

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var renderer = this,
      items = scene.items, o;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    if (!(o.image && o.image.url === o.url)) {
      o.image = renderer.loadImage(o.url);
      o.image.url = o.url;
    }

    var x = o.x || 0,
        y = o.y || 0,
        w = o.width || (o.image && o.image.width) || 0,
        h = o.height || (o.image && o.image.height) || 0,
        opac;
    x = x - (o.align==='center' ? w/2 : o.align==='right' ? w : 0);
    y = y - (o.baseline==='middle' ? h/2 : o.baseline==='bottom' ? h : 0);

    if (o.image.loaded) {
      g.globalAlpha = (opac = o.opacity) != null ? opac : 1;
      g.drawImage(o.image, x, y, w, h);
    }
  }
}

module.exports = {
  draw: draw,
  pick: util.pick()
};
},{"./util":24}],17:[function(require,module,exports){
module.exports = {
  arc:    require('./arc'),
  area:   require('./area'),
  group:  require('./group'),
  image:  require('./image'),
  line:   require('./line'),
  path:   require('./path'),
  rect:   require('./rect'),
  rule:   require('./rule'),
  symbol: require('./symbol'),
  text:   require('./text')
};

},{"./arc":13,"./area":14,"./group":15,"./image":16,"./line":18,"./path":19,"./rect":20,"./rule":21,"./symbol":22,"./text":23}],18:[function(require,module,exports){
var util = require('./util'),
    parse = require('../../../path/parse'),
    render = require('../../../path/render'),
    linePath = require('../../../util/svg').path.line;
    
function path(g, items) {
  var o = items[0],
      p = o.pathCache || (o.pathCache = parse(linePath(items)));
  render(g, p);
}

function pick(g, scene, x, y, gx, gy) {
  var items = scene.items,
      b = scene.bounds;

  if (!items || !items.length || b && !b.contains(gx, gy)) {
    return null;
  }

  if (g.pixelratio != null && g.pixelratio !== 1) {
    x *= g.pixelratio;
    y *= g.pixelratio;
  }
  return hit(g, items, x, y) ? items[0] : null;
}

var hit = util.testPath(path, false);

module.exports = {
  draw: util.drawOne(path),
  pick: pick,
  nested: true
};

},{"../../../path/parse":6,"../../../path/render":7,"../../../util/svg":40,"./util":24}],19:[function(require,module,exports){
var util = require('./util'),
    parse = require('../../../path/parse'),
    render = require('../../../path/render');

function path(g, o) {
  if (o.path == null) return true;
  var p = o.pathCache || (o.pathCache = parse(o.path));
  render(g, p, o.x, o.y);
}

module.exports = {
  draw: util.drawAll(path),
  pick: util.pickPath(path)
};

},{"../../../path/parse":6,"../../../path/render":7,"./util":24}],20:[function(require,module,exports){
var util = require('./util');

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var items = scene.items,
      o, opac, x, y, w, h;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    opac = o.opacity == null ? 1 : o.opacity;
    if (opac === 0) continue;

    x = o.x || 0;
    y = o.y || 0;
    w = o.width || 0;
    h = o.height || 0;

    if (o.fill && util.fill(g, o, opac)) {
      g.fillRect(x, y, w, h);
    }
    if (o.stroke && util.stroke(g, o, opac)) {
      g.strokeRect(x, y, w, h);
    }
  }
}

module.exports = {
  draw: draw,
  pick: util.pick()
};
},{"./util":24}],21:[function(require,module,exports){
var util = require('./util');

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var items = scene.items,
      o, opac, x1, y1, x2, y2;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    opac = o.opacity == null ? 1 : o.opacity;
    if (opac === 0) continue;
      
    x1 = o.x || 0;
    y1 = o.y || 0;
    x2 = o.x2 != null ? o.x2 : x1;
    y2 = o.y2 != null ? o.y2 : y1;

    if (o.stroke && util.stroke(g, o, opac)) {
      g.beginPath();
      g.moveTo(x1, y1);
      g.lineTo(x2, y2);
      g.stroke();
    }
  }
}

function stroke(g, o) {
  var x1 = o.x || 0,
      y1 = o.y || 0,
      x2 = o.x2 != null ? o.x2 : x1,
      y2 = o.y2 != null ? o.y2 : y1,
      lw = o.strokeWidth,
      lc = o.strokeCap;

  g.lineWidth = lw != null ? lw : 1;
  g.lineCap   = lc != null ? lc : 'butt';
  g.beginPath();
  g.moveTo(x1, y1);
  g.lineTo(x2, y2);
}

function hit(g, o, x, y) {
  if (!g.isPointInStroke) return false;
  stroke(g, o);
  return g.isPointInStroke(x, y);
}

module.exports = {
  draw: draw,
  pick: util.pick(hit)
};

},{"./util":24}],22:[function(require,module,exports){
var util = require('./util');

var sqrt3 = Math.sqrt(3),
    tan30 = Math.tan(30 * Math.PI / 180);

function path(g, o) {
  var size = o.size != null ? o.size : 100,
      x = o.x, y = o.y, r, t, rx, ry;

  g.beginPath();

  if (o.shape == null || o.shape === 'circle') {
    r = Math.sqrt(size / Math.PI);
    g.arc(x, y, r, 0, 2*Math.PI, 0);
    g.closePath();
    return;
  }

  switch (o.shape) {
    case 'cross':
      r = Math.sqrt(size / 5) / 2;
      t = 3*r;
      g.moveTo(x-t, y-r);
      g.lineTo(x-r, y-r);
      g.lineTo(x-r, y-t);
      g.lineTo(x+r, y-t);
      g.lineTo(x+r, y-r);
      g.lineTo(x+t, y-r);
      g.lineTo(x+t, y+r);
      g.lineTo(x+r, y+r);
      g.lineTo(x+r, y+t);
      g.lineTo(x-r, y+t);
      g.lineTo(x-r, y+r);
      g.lineTo(x-t, y+r);
      break;

    case 'diamond':
      ry = Math.sqrt(size / (2 * tan30));
      rx = ry * tan30;
      g.moveTo(x, y-ry);
      g.lineTo(x+rx, y);
      g.lineTo(x, y+ry);
      g.lineTo(x-rx, y);
      break;

    case 'square':
      t = Math.sqrt(size);
      r = t / 2;
      g.rect(x-r, y-r, t, t);
      break;

    case 'triangle-down':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      g.moveTo(x, y+ry);
      g.lineTo(x+rx, y-ry);
      g.lineTo(x-rx, y-ry);
      break;

    case 'triangle-up':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      g.moveTo(x, y-ry);
      g.lineTo(x+rx, y+ry);
      g.lineTo(x-rx, y+ry);
  }
  g.closePath();
}

module.exports = {
  draw: util.drawAll(path),
  pick: util.pickPath(path)
};
},{"./util":24}],23:[function(require,module,exports){
var Bounds = require('../../../util/Bounds'),
    textBounds = require('../../../util/bound').text,
    text = require('../../../util/text'),
    util = require('./util'),
    tempBounds = new Bounds();

function draw(g, scene, bounds) {
  if (!scene.items || !scene.items.length) return;

  var items = scene.items,
      o, opac, x, y, r, t, str;

  for (var i=0, len=items.length; i<len; ++i) {
    o = items[i];
    if (bounds && !bounds.intersects(o.bounds))
      continue; // bounds check

    str = text.value(o.text);
    if (!str) continue;
    opac = o.opacity == null ? 1 : o.opacity;
    if (opac === 0) continue;

    g.font = text.font(o);
    g.textAlign = o.align || 'left';

    x = (o.x || 0);
    y = (o.y || 0);
    if ((r = o.radius)) {
      t = (o.theta || 0) - Math.PI/2;
      x += r * Math.cos(t);
      y += r * Math.sin(t);
    }

    if (o.angle) {
      g.save();
      g.translate(x, y);
      g.rotate(o.angle * Math.PI/180);
      x = y = 0; // reset x, y
    }
    x += (o.dx || 0);
    y += (o.dy || 0) + text.offset(o);

    if (o.fill && util.fill(g, o, opac)) {
      g.fillText(str, x, y);
    }
    if (o.stroke && util.stroke(g, o, opac)) {
      g.strokeText(str, x, y);
    }
    if (o.angle) g.restore();
  }
}

function hit(g, o, x, y, gx, gy) {
  if (o.fontSize <= 0) return false;
  if (!o.angle) return true; // bounds sufficient if no rotation

  // project point into space of unrotated bounds
  var b = textBounds(o, tempBounds, true),
      a = -o.angle * Math.PI / 180,
      cos = Math.cos(a),
      sin = Math.sin(a),
      ox = o.x,
      oy = o.y,
      px = cos*gx - sin*gy + (ox - ox*cos + oy*sin),
      py = sin*gx + cos*gy + (oy - ox*sin - oy*cos);

  return b.contains(px, py);
}

module.exports = {
  draw: draw,
  pick: util.pick(hit)
};

},{"../../../util/Bounds":31,"../../../util/bound":36,"../../../util/text":41,"./util":24}],24:[function(require,module,exports){
function drawPathOne(path, g, o, items) {
  if (path(g, items)) return;

  var opac = o.opacity == null ? 1 : o.opacity;
  if (opac===0) return;

  if (o.fill && fill(g, o, opac)) { g.fill(); }
  if (o.stroke && stroke(g, o, opac)) { g.stroke(); }
}

function drawPathAll(path, g, scene, bounds) {
  var i, len, item;
  for (i=0, len=scene.items.length; i<len; ++i) {
    item = scene.items[i];
    if (!bounds || bounds.intersects(item.bounds)) {
      drawPathOne(path, g, item, item);
    }
  }
}

function drawAll(pathFunc) {
  return function(g, scene, bounds) {
    drawPathAll(pathFunc, g, scene, bounds);
  };
}

function drawOne(pathFunc) {
  return function(g, scene, bounds) {
    if (!scene.items.length) return;
    if (!bounds || bounds.intersects(scene.bounds)) {
      drawPathOne(pathFunc, g, scene.items[0], scene.items);
    }
  };
}

var trueFunc = function() { return true; };

function pick(test) {
  if (!test) test = trueFunc;

  return function(g, scene, x, y, gx, gy) {
    if (!scene.items.length) return null;

    var o, b, i;

    if (g.pixelratio != null && g.pixelratio !== 1) {
      x *= g.pixelratio;
      y *= g.pixelratio;
    }

    for (i=scene.items.length; --i >= 0;) {
      o = scene.items[i]; b = o.bounds;
      // first hit test against bounding box
      if ((b && !b.contains(gx, gy)) || !b) continue;
      // if in bounding box, perform more careful test
      if (test(g, o, x, y, gx, gy)) return o;
    }
    return null;
  };
}

function testPath(path, filled) {
  return function(g, o, x, y) {
    var item = Array.isArray(o) ? o[0] : o,
        fill = (filled == null) ? item.fill : filled,
        stroke = item.stroke && g.isPointInStroke, lw, lc;

    if (stroke) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      g.lineWidth = lw != null ? lw : 1;
      g.lineCap   = lc != null ? lc : 'butt';
    }

    return path(g, o) ? false :
      (fill && g.isPointInPath(x, y)) ||
      (stroke && g.isPointInStroke(x, y));
  };
}

function pickPath(path) {
  return pick(testPath(path));
}

function fill(g, o, opacity) {
  opacity *= (o.fillOpacity==null ? 1 : o.fillOpacity);
  if (opacity > 0) {
    g.globalAlpha = opacity;
    g.fillStyle = color(g, o, o.fill);
    return true;
  } else {
    return false;
  }
}

function stroke(g, o, opacity) {
  var lw = (lw = o.strokeWidth) != null ? lw : 1, lc;
  if (lw <= 0) return false;

  opacity *= (o.strokeOpacity==null ? 1 : o.strokeOpacity);
  if (opacity > 0) {
    g.globalAlpha = opacity;
    g.strokeStyle = color(g, o, o.stroke);
    g.lineWidth = lw;
    g.lineCap = (lc = o.strokeCap) != null ? lc : 'butt';
    g.vgLineDash(o.strokeDash || null);
    g.vgLineDashOffset(o.strokeDashOffset || 0);
    return true;
  } else {
    return false;
  }
}

function color(g, o, value) {
  return (value.id) ?
    gradient(g, value, o.bounds) :
    value;
}

function gradient(g, p, b) {
  var w = b.width(),
      h = b.height(),
      x1 = b.x1 + p.x1 * w,
      y1 = b.y1 + p.y1 * h,
      x2 = b.x1 + p.x2 * w,
      y2 = b.y1 + p.y2 * h,
      grad = g.createLinearGradient(x1, y1, x2, y2),
      stop = p.stops,
      i, n;

  for (i=0, n=stop.length; i<n; ++i) {
    grad.addColorStop(stop[i].offset, stop[i].color);
  }
  return grad;
}

module.exports = {
  drawOne:  drawOne,
  drawAll:  drawAll,
  pick:     pick,
  pickPath: pickPath,
  testPath: testPath,
  stroke:   stroke,
  fill:     fill,
  color:    color,
  gradient: gradient
};

},{}],25:[function(require,module,exports){
module.exports = {
  'canvas': require('./canvas'),
  'svg':    require('./svg')
};

},{"./canvas":12,"./svg":29}],26:[function(require,module,exports){
var DOM = require('../../util/dom'),
    Handler = require('../Handler');

function SVGHandler() {
  Handler.call(this);
}

var base = Handler.prototype;
var prototype = (SVGHandler.prototype = Object.create(base));
prototype.constructor = SVGHandler;

prototype.initialize = function(el, pad, obj) {
  this._svg = DOM.find(el, 'svg');
  return base.initialize.call(this, el, pad, obj);
};

prototype.svg = function() {
  return this._svg;
};

// wrap an event listener for the SVG DOM
prototype.listener = function(handler) {
  var that = this;
  return function(evt) {
    var target = evt.target,
        item = target.__data__;
    evt.vegaType = evt.type;
    item = Array.isArray(item) ? item[0] : item;
    handler.call(that._obj, evt, item);
  };
};

// add an event handler
prototype.on = function(type, handler) {
  var name = this.eventName(type),
      svg = this._svg,
      h = this._handlers,
      x = {
        type:     type,
        handler:  handler,
        listener: this.listener(handler)
      };

  (h[name] || (h[name] = [])).push(x);
  svg.addEventListener(name, x.listener);
  return this;
};

// remove an event handler
prototype.off = function(type, handler) {
  var name = this.eventName(type),
      svg = this._svg,
      h = this._handlers[name], i;
  if (!h) return;
  for (i=h.length; --i>=0;) {
    if (h[i].type === type && !handler || h[i].handler === handler) {
      svg.removeEventListener(name, h[i].listener);
      h.splice(i, 1);
    }
  }
  return this;
};

module.exports = SVGHandler;

},{"../../util/dom":38,"../Handler":8}],27:[function(require,module,exports){
var ImageLoader = require('../../util/ImageLoader'),
    Renderer = require('../Renderer'),
    text = require('../../util/text'),
    DOM = require('../../util/dom'),
    SVG = require('../../util/svg'),
    ns = SVG.metadata.xmlns,
    marks = require('./marks');

function SVGRenderer(loadConfig) {
  Renderer.call(this);
  this._loader = new ImageLoader(loadConfig);
  this._dirtyID = 0;
}

var base = Renderer.prototype;
var prototype = (SVGRenderer.prototype = Object.create(base));
prototype.constructor = SVGRenderer;

prototype.initialize = function(el, width, height, padding) {
  if (el) {
    this._svg = DOM.child(el, 0, 'svg', ns, 'marks');
    DOM.clear(el, 1);
    // set the svg root group
    this._root = DOM.child(this._svg, 0, 'g', ns);
    DOM.clear(this._svg, 1);
  }

  // create the svg definitions cache
  this._defs = {
    clip_id:  1,
    gradient: {},
    clipping: {}
  };

  // set background color if defined
  this.background(this._bgcolor);

  return base.initialize.call(this, el, width, height, padding);
};

prototype.background = function(bgcolor) {
  if (arguments.length && this._svg) {
    this._svg.style.setProperty('background-color', bgcolor);
  }
  return base.background.apply(this, arguments);
};

prototype.resize = function(width, height, padding) {
  base.resize.call(this, width, height, padding);
  
  if (this._svg) {
    var w = this._width,
        h = this._height,
        p = this._padding;
  
    this._svg.setAttribute('width', w + p.left + p.right);
    this._svg.setAttribute('height', h + p.top + p.bottom);
    
    this._root.setAttribute('transform', 'translate('+p.left+','+p.top+')');
  }

  return this;
};

prototype.svg = function() {
  if (!this._svg) return null;

  var attr = {
    'class':  'marks',
    'width':  this._width + this._padding.left + this._padding.right,
    'height': this._height + this._padding.top + this._padding.bottom,
  };
  for (var key in SVG.metadata) {
    attr[key] = SVG.metadata[key];
  }

  return DOM.openTag('svg', attr) + this._svg.innerHTML + DOM.closeTag('svg');
};

prototype.imageURL = function(url) {
  return this._loader.imageURL(url);
};


// -- Render entry point --

prototype.render = function(scene, items) {
  if (this._dirtyCheck(items)) {
    if (this._dirtyAll) this._resetDefs();
    this.draw(this._root, scene, -1);
    DOM.clear(this._root, 1);
  }
  this.updateDefs();
  return this;
};

prototype.draw = function(el, scene, index) {
  this.drawMark(el, scene, index, marks[scene.marktype]);
};


// -- Manage SVG definitions ('defs') block --

prototype.updateDefs = function() {
  var svg = this._svg,
      defs = this._defs,
      el = defs.el,
      index = 0, id;

  for (id in defs.gradient) {
    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));
    updateGradient(el, defs.gradient[id], index++);
  }

  for (id in defs.clipping) {
    if (!el) el = (defs.el = DOM.child(svg, 0, 'defs', ns));
    updateClipping(el, defs.clipping[id], index++);
  }

  // clean-up
  if (el) {
    if (index === 0) {
      svg.removeChild(el);
      defs.el = null;
    } else {
      DOM.clear(el, index);      
    }
  }
};

function updateGradient(el, grad, index) {
  var i, n, stop;

  el = DOM.child(el, index, 'linearGradient', ns);
  el.setAttribute('id', grad.id);
  el.setAttribute('x1', grad.x1);
  el.setAttribute('x2', grad.x2);
  el.setAttribute('y1', grad.y1);
  el.setAttribute('y2', grad.y2);
  
  for (i=0, n=grad.stops.length; i<n; ++i) {
    stop = DOM.child(el, i, 'stop', ns);
    stop.setAttribute('offset', grad.stops[i].offset);
    stop.setAttribute('stop-color', grad.stops[i].color);
  }
  DOM.clear(el, i);
}

function updateClipping(el, clip, index) {
  var rect;

  el = DOM.child(el, index, 'clipPath', ns);
  el.setAttribute('id', clip.id);
  rect = DOM.child(el, 0, 'rect', ns);
  rect.setAttribute('x', 0);
  rect.setAttribute('y', 0);
  rect.setAttribute('width', clip.width);
  rect.setAttribute('height', clip.height);
}

prototype._resetDefs = function() {
  var def = this._defs;
  def.clip_id = 1;
  def.gradient = {};
  def.clipping = {};
};


// -- Manage rendering of items marked as dirty --

prototype.isDirty = function(item) {
  return this._dirtyAll || item.dirty === this._dirtyID;
};

prototype._dirtyCheck = function(items) {
  this._dirtyAll = true;
  if (!items) return true;

  var id = ++this._dirtyID,
      item, mark, type, mdef, i, n, o;

  for (i=0, n=items.length; i<n; ++i) {
    item = items[i];
    mark = item.mark;
    if (mark.marktype !== type) {
      // memoize mark instance lookup
      type = mark.marktype;
      mdef = marks[type];
    }

    if (item.status === 'exit') { // EXIT
      if (item._svg) {
        if (mdef.nest && item.mark.items.length) {
          // if nested mark with remaining points, update instead
          this._update(mdef, item._svg, item.mark.items[0]);
          o = item.mark.items[0];
          o._svg = item._svg;
          o._update = id;
        } else {
          // otherwise remove from DOM
          DOM.remove(item._svg);
        }
        item._svg = null;
      }
      continue;
    }

    item = (mdef.nest ? mark.items[0] : item);
    if (item._update === id) { // Already processed
      continue;
    } else if (item._svg) { // UPDATE
      this._update(mdef, item._svg, item);
    } else { // ENTER
      this._dirtyAll = false;
      dirtyParents(item, id);
    }
    item._update = id;
  }
  return !this._dirtyAll;
};

function dirtyParents(item, id) {
  for (; item && item.dirty !== id; item=item.mark.group) {
    item.dirty = id;
    if (item.mark && item.mark.dirty !== id) {
      item.mark.dirty = id;
    } else return;
  }
}


// -- Construct & maintain scenegraph to SVG mapping ---

// Draw a mark container.
prototype.drawMark = function(el, scene, index, mdef) {
  if (!this.isDirty(scene)) return;

  var items = mdef.nest ?
        (scene.items && scene.items.length ? [scene.items[0]] : []) :
        scene.items || [],
      events = scene.interactive === false ? 'none' : null,
      isGroup = (mdef.tag === 'g'),
      className = DOM.cssClass(scene),
      p, i, n, c, d, insert;

  p = DOM.child(el, index+1, 'g', ns, className);
  p.setAttribute('class', className);
  scene._svg = p;
  if (!isGroup && events) {
    p.style.setProperty('pointer-events', events);
  }

  for (i=0, n=items.length; i<n; ++i) {
    if (this.isDirty(d = items[i])) {
      insert = !(this._dirtyAll || d._svg);
      c = bind(p, mdef, d, i, insert);
      this._update(mdef, c, d);
      if (isGroup) {
        if (insert) this._dirtyAll = true;
        this._recurse(c, d);
        if (insert) this._dirtyAll = false;
      }
    }
  }
  DOM.clear(p, i);
  return p;
};

// Recursively process group contents.
prototype._recurse = function(el, group) {
  var items = group.items || [],
      legends = group.legendItems || [],
      axes = group.axisItems || [],
      idx = 0, j, m;

  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer === 'back') {
      this.drawMark(el, axes[j], idx++, marks.group);
    }
  }
  for (j=0, m=items.length; j<m; ++j) {
    this.draw(el, items[j], idx++);
  }
  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer !== 'back') {
      this.drawMark(el, axes[j], idx++, marks.group);
    }
  }
  for (j=0, m=legends.length; j<m; ++j) {
    this.drawMark(el, legends[j], idx++, marks.group);
  }

  // remove any extraneous DOM elements
  DOM.clear(el, 1 + idx);
};

// Bind a scenegraph item to an SVG DOM element.
// Create new SVG elements as needed.
function bind(el, mdef, item, index, insert) {
  // create svg element, bind item data for D3 compatibility
  var node = DOM.child(el, index, mdef.tag, ns, null, insert);
  node.__data__ = item;
  node.__values__ = {fill: 'default'};

  // create background rect
  if (mdef.tag === 'g') {
    var bg = DOM.child(node, 0, 'rect', ns, 'background');
    bg.__data__ = item;
  }

  // add pointer from scenegraph item to svg element
  return (item._svg = node);
}


// -- Set attributes & styles on SVG elements ---

var element = null, // temp var for current SVG element
    values = null;  // temp var for current values hash

// Extra configuration for certain mark types
var mark_extras = {
  group: function(mdef, el, item) {
    element = el.childNodes[0];
    values = el.__values__; // use parent's values hash
    mdef.background(emit, item, this);

    var value = item.mark.interactive === false ? 'none' : null;
    if (value !== values.events) {
      element.style.setProperty('pointer-events', value);
      values.events = value;
    }
  },
  text: function(mdef, el, item) {
    var str = text.value(item.text);
    if (str !== values.text) {
      el.textContent = str;
      values.text = str;
    }
    str = text.font(item);
    if (str !== values.font) {
      el.style.setProperty('font', str);
      values.font = str;
    }
  }
};

prototype._update = function(mdef, el, item) {
  // set dom element and values cache
  // provides access to emit method
  element = el;
  values = el.__values__;

  // apply svg attributes
  mdef.attr(emit, item, this);

  // some marks need special treatment
  var extra = mark_extras[mdef.type];
  if (extra) extra(mdef, el, item);

  // apply svg css styles
  // note: element may be modified by 'extra' method
  this.style(element, item);
};

function emit(name, value, ns) {
  // early exit if value is unchanged
  if (value === values[name]) return;

  if (value != null) {
    // if value is provided, update DOM attribute
    if (ns) {
      element.setAttributeNS(ns, name, value);
    } else {
      element.setAttribute(name, value);
    }
  } else {
    // else remove DOM attribute
    if (ns) {
      element.removeAttributeNS(ns, name);
    } else {
      element.removeAttribute(name);
    }
  }

  // note current value for future comparison
  values[name] = value;
}

prototype.style = function(el, o) {
  if (o == null) return;
  var i, n, prop, name, value;

  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {
    prop = SVG.styleProperties[i];
    value = o[prop];
    if (value === values[prop]) continue;

    name = SVG.styles[prop];
    if (value == null) {
      if (name === 'fill') {
        el.style.setProperty(name, 'none');
      } else {
        el.style.removeProperty(name);
      }
    } else {
      if (value.id) {
        // ensure definition is included
        this._defs.gradient[value.id] = value;
        value = 'url(' + href() + '#' + value.id + ')';
      }
      el.style.setProperty(name, value+'');
    }

    values[prop] = value;
  }
};

function href() {
  return typeof window !== 'undefined' ? window.location.href : '';
}

module.exports = SVGRenderer;

},{"../../util/ImageLoader":34,"../../util/dom":38,"../../util/svg":40,"../../util/text":41,"../Renderer":9,"./marks":30}],28:[function(require,module,exports){
var Renderer = require('../Renderer'),
    ImageLoader = require('../../util/ImageLoader'),
    SVG = require('../../util/svg'),
    text = require('../../util/text'),
    DOM = require('../../util/dom'),
    openTag = DOM.openTag,
    closeTag = DOM.closeTag,
    MARKS = require('./marks');

function SVGStringRenderer(loadConfig) {
  Renderer.call(this);

  this._loader = new ImageLoader(loadConfig);

  this._text = {
    head: '',
    root: '',
    foot: '',
    defs: '',
    body: ''
  };

  this._defs = {
    clip_id:  1,
    gradient: {},
    clipping: {}
  };
}

var base = Renderer.prototype;
var prototype = (SVGStringRenderer.prototype = Object.create(base));
prototype.constructor = SVGStringRenderer;

prototype.resize = function(width, height, padding) {
  base.resize.call(this, width, height, padding);
  var p = this._padding,
      t = this._text;

  var attr = {
    'class':  'marks',
    'width':  this._width + p.left + p.right,
    'height': this._height + p.top + p.bottom,
  };
  for (var key in SVG.metadata) {
    attr[key] = SVG.metadata[key];
  }

  t.head = openTag('svg', attr);
  t.root = openTag('g', {
    transform: 'translate(' + p.left + ',' + p.top + ')'
  });
  t.foot = closeTag('g') + closeTag('svg');

  return this;
};

prototype.svg = function() {
  var t = this._text;
  return t.head + t.defs + t.root + t.body + t.foot;
};

prototype.render = function(scene) {
  this._text.body = this.mark(scene);
  this._text.defs = this.buildDefs();
  return this;
};

prototype.reset = function() {
  this._defs.clip_id = 0;
  return this;
};

prototype.buildDefs = function() {
  var all = this._defs,
      defs = '',
      i, id, def, stops;

  for (id in all.gradient) {
    def = all.gradient[id];
    stops = def.stops;

    defs += openTag('linearGradient', {
      id: id,
      x1: def.x1,
      x2: def.x2,
      y1: def.y1,
      y2: def.y2
    });
    
    for (i=0; i<stops.length; ++i) {
      defs += openTag('stop', {
        offset: stops[i].offset,
        'stop-color': stops[i].color
      }) + closeTag('stop');
    }
    
    defs += closeTag('linearGradient');
  }
  
  for (id in all.clipping) {
    def = all.clipping[id];

    defs += openTag('clipPath', {id: id});

    defs += openTag('rect', {
      x: 0,
      y: 0,
      width: def.width,
      height: def.height
    }) + closeTag('rect');

    defs += closeTag('clipPath');
  }
  
  return (defs.length > 0) ? openTag('defs') + defs + closeTag('defs') : '';
};

prototype.imageURL = function(url) {
  return this._loader.imageURL(url);
};

var object;

function emit(name, value, ns, prefixed) {
  object[prefixed || name] = value;
}

prototype.attributes = function(attr, item) {
  object = {};
  attr(emit, item, this);
  return object;
};

prototype.mark = function(scene) {
  var mdef = MARKS[scene.marktype],
      tag  = mdef.tag,
      attr = mdef.attr,
      nest = mdef.nest || false,
      data = nest ?
          (scene.items && scene.items.length ? [scene.items[0]] : []) :
          (scene.items || []),
      defs = this._defs,
      str = '',
      style, i, item;

  if (tag !== 'g' && scene.interactive === false) {
    style = 'style="pointer-events: none;"';
  }

  // render opening group tag
  str += openTag('g', {
    'class': DOM.cssClass(scene)
  }, style);

  // render contained elements
  for (i=0; i<data.length; ++i) {
    item = data[i];
    style = (tag !== 'g') ? styles(item, scene, tag, defs) : null;
    str += openTag(tag, this.attributes(attr, item), style);
    if (tag === 'text') {
      str += escape_text(text.value(item.text));
    } else if (tag === 'g') {
      str += openTag('rect',
        this.attributes(mdef.background, item),
        styles(item, scene, 'bgrect', defs)) + closeTag('rect');
      str += this.markGroup(item);
    }
    str += closeTag(tag);
  }

  // render closing group tag
  return str + closeTag('g');
};

prototype.markGroup = function(scene) {
  var str = '',
      axes = scene.axisItems || [],
      items = scene.items || [],
      legends = scene.legendItems || [],
      j, m;

  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer === 'back') {
      str += this.mark(axes[j]);
    }
  }
  for (j=0, m=items.length; j<m; ++j) {
    str += this.mark(items[j]);
  }
  for (j=0, m=axes.length; j<m; ++j) {
    if (axes[j].layer !== 'back') {
      str += this.mark(axes[j]);
    }
  }
  for (j=0, m=legends.length; j<m; ++j) {
    str += this.mark(legends[j]);
  }

  return str;
};

function styles(o, mark, tag, defs) {
  if (o == null) return '';
  var i, n, prop, name, value, s = '';

  if (tag === 'bgrect' && mark.interactive === false) {
    s += 'pointer-events: none;';
  }

  if (tag === 'text') {
    s += 'font: ' + text.font(o) + ';';
  }

  for (i=0, n=SVG.styleProperties.length; i<n; ++i) {
    prop = SVG.styleProperties[i];
    name = SVG.styles[prop];
    value = o[prop];

    if (value == null) {
      if (name === 'fill') {
        s += (s.length ? ' ' : '') + 'fill: none;';
      }
    } else {
      if (value.id) {
        // ensure definition is included
        defs.gradient[value.id] = value;
        value = 'url(#' + value.id + ')';
      }
      s += (s.length ? ' ' : '') + name + ': ' + value + ';';
    }
  }

  return s ? 'style="' + s + '"' : null;
}

function escape_text(s) {
  return s.replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
}

module.exports = SVGStringRenderer;

},{"../../util/ImageLoader":34,"../../util/dom":38,"../../util/svg":40,"../../util/text":41,"../Renderer":9,"./marks":30}],29:[function(require,module,exports){
module.exports = {
  Handler:  require('./SVGHandler'),
  Renderer: require('./SVGRenderer'),
  string: {
    Renderer : require('./SVGStringRenderer')
  }
};
},{"./SVGHandler":26,"./SVGRenderer":27,"./SVGStringRenderer":28}],30:[function(require,module,exports){
var text = require('../../util/text'),
    SVG = require('../../util/svg'),
    textAlign = SVG.textAlign,
    path = SVG.path;

function translateItem(o) {
  return translate(o.x || 0, o.y || 0);
}

function translate(x, y) {
  return 'translate(' + x + ',' + y + ')';
}

module.exports = {
  arc: {
    tag:  'path',
    type: 'arc',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('d', path.arc(o));
    }
  },
  area: {
    tag:  'path',
    type: 'area',
    nest: true,
    attr: function(emit, o) {
      var items = o.mark.items;
      if (items.length) emit('d', path.area(items));
    }
  },
  group: {
    tag:  'g',
    type: 'group',
    attr: function(emit, o, renderer) {
      var id = null, defs, c;
      emit('transform', translateItem(o));
      if (o.clip) {
        defs = renderer._defs;
        id = o.clip_id || (o.clip_id = 'clip' + defs.clip_id++);
        c = defs.clipping[id] || (defs.clipping[id] = {id: id});
        c.width = o.width || 0;
        c.height = o.height || 0;
      }
      emit('clip-path', id ? ('url(#' + id + ')') : null);
    },
    background: function(emit, o) {
      emit('class', 'background');
      emit('width', o.width || 0);
      emit('height', o.height || 0);
    }
  },
  image: {
    tag:  'image',
    type: 'image',
    attr: function(emit, o, renderer) {
      var x = o.x || 0,
          y = o.y || 0,
          w = o.width || 0,
          h = o.height || 0,
          url = renderer.imageURL(o.url);

      x = x - (o.align === 'center' ? w/2 : o.align === 'right' ? w : 0);
      y = y - (o.baseline === 'middle' ? h/2 : o.baseline === 'bottom' ? h : 0);

      emit('href', url, 'http://www.w3.org/1999/xlink', 'xlink:href');
      emit('transform', translate(x, y));
      emit('width', w);
      emit('height', h);
    }
  },
  line: {
    tag:  'path',
    type: 'line',
    nest: true,
    attr: function(emit, o) {
      var items = o.mark.items;
      if (items.length) emit('d', path.line(items));
    }
  },
  path: {
    tag:  'path',
    type: 'path',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('d', o.path);
    }
  },
  rect: {
    tag:  'rect',
    type: 'rect',
    nest: false,
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('width', o.width || 0);
      emit('height', o.height || 0);
    }
  },
  rule: {
    tag:  'line',
    type: 'rule',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('x2', o.x2 != null ? o.x2 - (o.x||0) : 0);
      emit('y2', o.y2 != null ? o.y2 - (o.y||0) : 0);
    }
  },
  symbol: {
    tag:  'path',
    type: 'symbol',
    attr: function(emit, o) {
      emit('transform', translateItem(o));
      emit('d', path.symbol(o));
    }
  },
  text: {
    tag:  'text',
    type: 'text',
    nest: false,
    attr: function(emit, o) {
      var dx = (o.dx || 0),
          dy = (o.dy || 0) + text.offset(o),
          x = (o.x || 0),
          y = (o.y || 0),
          a = o.angle || 0,
          r = o.radius || 0, t;

      if (r) {
        t = (o.theta || 0) - Math.PI/2;
        x += r * Math.cos(t);
        y += r * Math.sin(t);
      }

      emit('text-anchor', textAlign[o.align] || 'start');
      
      if (a) {
        t = translate(x, y) + ' rotate('+a+')';
        if (dx || dy) t += ' ' + translate(dx, dy);
      } else {
        t = translate(x+dx, y+dy);
      }
      emit('transform', t);
    }
  }
};

},{"../../util/svg":40,"../../util/text":41}],31:[function(require,module,exports){
function Bounds(b) {
  this.clear();
  if (b) this.union(b);
}

var prototype = Bounds.prototype;

prototype.clone = function() {
  return new Bounds(this);
};

prototype.clear = function() {
  this.x1 = +Number.MAX_VALUE;
  this.y1 = +Number.MAX_VALUE;
  this.x2 = -Number.MAX_VALUE;
  this.y2 = -Number.MAX_VALUE;
  return this;
};

prototype.set = function(x1, y1, x2, y2) {
  this.x1 = x1;
  this.y1 = y1;
  this.x2 = x2;
  this.y2 = y2;
  return this;
};

prototype.add = function(x, y) {
  if (x < this.x1) this.x1 = x;
  if (y < this.y1) this.y1 = y;
  if (x > this.x2) this.x2 = x;
  if (y > this.y2) this.y2 = y;
  return this;
};

prototype.expand = function(d) {
  this.x1 -= d;
  this.y1 -= d;
  this.x2 += d;
  this.y2 += d;
  return this;
};

prototype.round = function() {
  this.x1 = Math.floor(this.x1);
  this.y1 = Math.floor(this.y1);
  this.x2 = Math.ceil(this.x2);
  this.y2 = Math.ceil(this.y2);
  return this;
};

prototype.translate = function(dx, dy) {
  this.x1 += dx;
  this.x2 += dx;
  this.y1 += dy;
  this.y2 += dy;
  return this;
};

prototype.rotate = function(angle, x, y) {
  var cos = Math.cos(angle),
      sin = Math.sin(angle),
      cx = x - x*cos + y*sin,
      cy = y - x*sin - y*cos,
      x1 = this.x1, x2 = this.x2,
      y1 = this.y1, y2 = this.y2;

  return this.clear()
    .add(cos*x1 - sin*y1 + cx,  sin*x1 + cos*y1 + cy)
    .add(cos*x1 - sin*y2 + cx,  sin*x1 + cos*y2 + cy)
    .add(cos*x2 - sin*y1 + cx,  sin*x2 + cos*y1 + cy)
    .add(cos*x2 - sin*y2 + cx,  sin*x2 + cos*y2 + cy);
};

prototype.union = function(b) {
  if (b.x1 < this.x1) this.x1 = b.x1;
  if (b.y1 < this.y1) this.y1 = b.y1;
  if (b.x2 > this.x2) this.x2 = b.x2;
  if (b.y2 > this.y2) this.y2 = b.y2;
  return this;
};

prototype.encloses = function(b) {
  return b && (
    this.x1 <= b.x1 &&
    this.x2 >= b.x2 &&
    this.y1 <= b.y1 &&
    this.y2 >= b.y2
  );
};

prototype.alignsWith = function(b) {
  return b && (
    this.x1 == b.x1 ||
    this.x2 == b.x2 ||
    this.y1 == b.y1 ||
    this.y2 == b.y2
  );
};

prototype.intersects = function(b) {
  return b && !(
    this.x2 < b.x1 ||
    this.x1 > b.x2 ||
    this.y2 < b.y1 ||
    this.y1 > b.y2
  );
};

prototype.contains = function(x, y) {
  return !(
    x < this.x1 ||
    x > this.x2 ||
    y < this.y1 ||
    y > this.y2
  );
};

prototype.width = function() {
  return this.x2 - this.x1;
};

prototype.height = function() {
  return this.y2 - this.y1;
};

module.exports = Bounds;

},{}],32:[function(require,module,exports){
module.exports = function(b) {
  function noop() { }
  function add(x,y) { b.add(x, y); }

  return {
    bounds: function(_) {
      if (!arguments.length) return b;
      return (b = _, this);
    },
    beginPath: noop,
    closePath: noop,
    moveTo: add,
    lineTo: add,
    quadraticCurveTo: function(x1, y1, x2, y2) {
      b.add(x1, y1);
      b.add(x2, y2);
    },
    bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
      b.add(x1, y1);
      b.add(x2, y2);
      b.add(x3, y3);
    }
  };
};

},{}],33:[function(require,module,exports){
var gradient_id = 0;

function Gradient(type) {
  this.id = 'gradient_' + (gradient_id++);
  this.type = type || 'linear';
  this.stops = [];
  this.x1 = 0;
  this.x2 = 1;
  this.y1 = 0;
  this.y2 = 0;
}

var prototype = Gradient.prototype;

prototype.stop = function(offset, color) {
  this.stops.push({
    offset: offset,
    color: color
  });
  return this;
};

module.exports = Gradient;
},{}],34:[function(require,module,exports){
(function (global){
var load = require('datalib/src/import/load');

function ImageLoader(loadConfig) {
  this._pending = 0;
  this._config = loadConfig || ImageLoader.Config; 
}

// Overridable global default load configuration
ImageLoader.Config = null;

var prototype = ImageLoader.prototype;

prototype.pending = function() {
  return this._pending;
};

prototype.params = function(uri) {
  var p = {url: uri}, k;
  for (k in this._config) { p[k] = this._config[k]; }
  return p;
};

prototype.imageURL = function(uri) {
  return load.sanitizeUrl(this.params(uri));
};

function browser(uri, callback) {
  var url = load.sanitizeUrl(this.params(uri));
  if (!url) { // error
    if (callback) callback(uri, null);
    return null;
  }

  var loader = this,
      image = new Image();

  loader._pending += 1;

  image.onload = function() {
    loader._pending -= 1;
    image.loaded = true;
    if (callback) callback(null, image);
  };
  image.src = url;

  return image;
}

function server(uri, callback) {
  var loader = this,
      image = new ((typeof window !== "undefined" ? window['canvas'] : typeof global !== "undefined" ? global['canvas'] : null).Image)();

  loader._pending += 1;

  load(this.params(uri), function(err, data) {
    loader._pending -= 1;
    if (err) {
      if (callback) callback(err, null);
      return null;
    }
    image.src = data;
    image.loaded = true;
    if (callback) callback(null, image);
  });

  return image;
}

prototype.loadImage = function(uri, callback) {
  return load.useXHR ?
    browser.call(this, uri, callback) :
    server.call(this, uri, callback);
};

module.exports = ImageLoader;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"datalib/src/import/load":2}],35:[function(require,module,exports){
function Item(mark) {
  this.mark = mark;
}

var prototype = Item.prototype;

prototype.hasPropertySet = function(name) {
  var props = this.mark.def.properties;
  return props && props[name] != null;
};

prototype.cousin = function(offset, index) {
  if (offset === 0) return this;
  offset = offset || -1;
  var mark = this.mark,
      group = mark.group,
      iidx = index==null ? mark.items.indexOf(this) : index,
      midx = group.items.indexOf(mark) + offset;
  return group.items[midx].items[iidx];
};

prototype.sibling = function(offset) {
  if (offset === 0) return this;
  offset = offset || -1;
  var mark = this.mark,
      iidx = mark.items.indexOf(this) + offset;
  return mark.items[iidx];
};

prototype.remove = function() {
  var item = this,
      list = item.mark.items,
      i = list.indexOf(item);
  if (i >= 0) {
    if (i===list.length-1) {
      list.pop();
    } else {
      list.splice(i, 1);
    }
  }
  return item;
};

prototype.touch = function() {
  if (this.pathCache) this.pathCache = null;
};

module.exports = Item;
},{}],36:[function(require,module,exports){
var BoundsContext = require('./BoundsContext'),
    Bounds = require('./Bounds'),
    canvas = require('./canvas'),
    svg = require('./svg'),
    text = require('./text'),
    paths = require('../path'),
    parse = paths.parse,
    drawPath = paths.render,
    areaPath = svg.path.area,
    linePath = svg.path.line,
    halfpi = Math.PI / 2,
    sqrt3 = Math.sqrt(3),
    tan30 = Math.tan(30 * Math.PI / 180),
    g2D = null,
    bc = BoundsContext();

function context() {
  return g2D || (g2D = canvas.instance(1,1).getContext('2d'));
}

function strokeBounds(o, bounds) {
  if (o.stroke && o.opacity !== 0 && o.stokeOpacity !== 0) {
    bounds.expand(o.strokeWidth != null ? o.strokeWidth : 1);
  }
  return bounds;
}

function pathBounds(o, path, bounds, x, y) {
  if (path == null) {
    bounds.set(0, 0, 0, 0);
  } else {
    drawPath(bc.bounds(bounds), path, x, y);
    strokeBounds(o, bounds);
  }
  return bounds;
}

function path(o, bounds) {
  var p = o.path ? o.pathCache || (o.pathCache = parse(o.path)) : null;
  return pathBounds(o, p, bounds, o.x, o.y);
}

function area(mark, bounds) {
  if (mark.items.length === 0) return bounds;
  var items = mark.items,
      item = items[0],
      p = item.pathCache || (item.pathCache = parse(areaPath(items)));
  return pathBounds(item, p, bounds);
}

function line(mark, bounds) {
  if (mark.items.length === 0) return bounds;
  var items = mark.items,
      item = items[0],
      p = item.pathCache || (item.pathCache = parse(linePath(items)));
  return pathBounds(item, p, bounds);
}

function rect(o, bounds) {
  var x, y;
  return strokeBounds(o, bounds.set(
    x = o.x || 0,
    y = o.y || 0,
    (x + o.width) || 0,
    (y + o.height) || 0
  ));
}

function image(o, bounds) {
  var x = o.x || 0,
      y = o.y || 0,
      w = o.width || 0,
      h = o.height || 0;
  x = x - (o.align === 'center' ? w/2 : (o.align === 'right' ? w : 0));
  y = y - (o.baseline === 'middle' ? h/2 : (o.baseline === 'bottom' ? h : 0));
  return bounds.set(x, y, x+w, y+h);
}

function rule(o, bounds) {
  var x1, y1;
  return strokeBounds(o, bounds.set(
    x1 = o.x || 0,
    y1 = o.y || 0,
    o.x2 != null ? o.x2 : x1,
    o.y2 != null ? o.y2 : y1
  ));
}

function arc(o, bounds) {
  var cx = o.x || 0,
      cy = o.y || 0,
      ir = o.innerRadius || 0,
      or = o.outerRadius || 0,
      sa = (o.startAngle || 0) - halfpi,
      ea = (o.endAngle || 0) - halfpi,
      xmin = Infinity, xmax = -Infinity,
      ymin = Infinity, ymax = -Infinity,
      a, i, n, x, y, ix, iy, ox, oy;

  var angles = [sa, ea],
      s = sa - (sa % halfpi);
  for (i=0; i<4 && s<ea; ++i, s+=halfpi) {
    angles.push(s);
  }

  for (i=0, n=angles.length; i<n; ++i) {
    a = angles[i];
    x = Math.cos(a); ix = ir*x; ox = or*x;
    y = Math.sin(a); iy = ir*y; oy = or*y;
    xmin = Math.min(xmin, ix, ox);
    xmax = Math.max(xmax, ix, ox);
    ymin = Math.min(ymin, iy, oy);
    ymax = Math.max(ymax, iy, oy);
  }

  return strokeBounds(o, bounds.set(
    cx + xmin,
    cy + ymin,
    cx + xmax,
    cy + ymax
  ));
}

function symbol(o, bounds) {
  var size = o.size != null ? o.size : 100,
      x = o.x || 0,
      y = o.y || 0,
      r, t, rx, ry;

  switch (o.shape) {
    case 'cross':
      t = 3 * Math.sqrt(size / 5) / 2;
      bounds.set(x-t, y-t, x+t, y+t);
      break;

    case 'diamond':
      ry = Math.sqrt(size / (2 * tan30));
      rx = ry * tan30;
      bounds.set(x-rx, y-ry, x+rx, y+ry);
      break;

    case 'square':
      t = Math.sqrt(size);
      r = t / 2;
      bounds.set(x-r, y-r, x+r, y+r);
      break;

    case 'triangle-down':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      bounds.set(x-rx, y-ry, x+rx, y+ry);
      break;

    case 'triangle-up':
      rx = Math.sqrt(size / sqrt3);
      ry = rx * sqrt3 / 2;
      bounds.set(x-rx, y-ry, x+rx, y+ry);
      break;

    default:
      r = Math.sqrt(size/Math.PI);
      bounds.set(x-r, y-r, x+r, y+r);
  }

  return strokeBounds(o, bounds);
}

function textMark(o, bounds, noRotate) {
  var g = context(),
      h = text.size(o),
      a = o.align,
      r = o.radius || 0,
      x = (o.x || 0),
      y = (o.y || 0),
      dx = (o.dx || 0),
      dy = (o.dy || 0) + text.offset(o) - Math.round(0.8*h), // use 4/5 offset
      w, t;

  if (r) {
    t = (o.theta || 0) - Math.PI/2;
    x += r * Math.cos(t);
    y += r * Math.sin(t);
  }

  // horizontal alignment
  g.font = text.font(o);
  w = g.measureText(text.value(o.text)).width;
  if (a === 'center') {
    dx -= (w / 2);
  } else if (a === 'right') {
    dx -= w;
  } else {
    // left by default, do nothing
  }

  bounds.set(dx+=x, dy+=y, dx+w, dy+h);
  if (o.angle && !noRotate) {
    bounds.rotate(o.angle*Math.PI/180, x, y);
  }
  return bounds.expand(noRotate ? 0 : 1);
}

function group(g, bounds, includeLegends) {
  var axes = g.axisItems || [],
      items = g.items || [],
      legends = g.legendItems || [],
      j, m;

  if (!g.clip) {
    for (j=0, m=axes.length; j<m; ++j) {
      bounds.union(axes[j].bounds);
    }
    for (j=0, m=items.length; j<m; ++j) {
      bounds.union(items[j].bounds);
    }
    if (includeLegends) {
      for (j=0, m=legends.length; j<m; ++j) {
        bounds.union(legends[j].bounds);
      }
    }
  }
  if (g.clip || g.width || g.height) {
    strokeBounds(g, bounds
      .add(0, 0)
      .add(g.width || 0, g.height || 0));
  }
  return bounds.translate(g.x || 0, g.y || 0);
}

var methods = {
  group:  group,
  symbol: symbol,
  image:  image,
  rect:   rect,
  rule:   rule,
  arc:    arc,
  text:   textMark,
  path:   path,
  area:   area,
  line:   line
};
methods.area.nest = true;
methods.line.nest = true;

function itemBounds(item, func, opt) {
  var type = item.mark.marktype;
  func = func || methods[type];
  if (func.nest) item = item.mark;

  var curr = item.bounds,
      prev = item['bounds:prev'] || (item['bounds:prev'] = new Bounds());

  if (curr) {
    prev.clear().union(curr);
    curr.clear();
  } else {
    item.bounds = new Bounds();
  }
  func(item, item.bounds, opt);
  if (!curr) prev.clear().union(item.bounds);
  return item.bounds;
}

var DUMMY_ITEM = {mark: null};

function markBounds(mark, bounds, opt) {
  var type  = mark.marktype,
      func  = methods[type],
      items = mark.items,
      hasi  = items && items.length,
      i, n, o, b;

  if (func.nest) {
    o = hasi ? items[0]
      : (DUMMY_ITEM.mark = mark, DUMMY_ITEM); // no items, so fake it
    b = itemBounds(o, func, opt);
    bounds = bounds && bounds.union(b) || b;
    return bounds;
  }

  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();
  if (hasi) {  
    for (i=0, n=items.length; i<n; ++i) {
      bounds.union(itemBounds(items[i], func, opt));
    }
  }
  return (mark.bounds = bounds);
}

module.exports = {
  mark:  markBounds,
  item:  itemBounds,
  text:  textMark,
  group: group
};

},{"../path":5,"./Bounds":31,"./BoundsContext":32,"./canvas":37,"./svg":40,"./text":41}],37:[function(require,module,exports){
(function (global){
function instance(w, h) {
  w = w || 1;
  h = h || 1;
  var canvas;

  if (typeof document !== 'undefined' && document.createElement) {
    canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
  } else {
    var Canvas = (typeof window !== "undefined" ? window['canvas'] : typeof global !== "undefined" ? global['canvas'] : null);
    if (!Canvas.prototype) return null;
    canvas = new Canvas(w, h);
  }
  return lineDash(canvas);
}

function resize(canvas, w, h, p, retina) {
  var g = this._ctx = canvas.getContext('2d'), 
      s = 1;

  canvas.width = w + p.left + p.right;
  canvas.height = h + p.top + p.bottom;

  // if browser canvas, attempt to modify for retina display
  if (retina && typeof HTMLElement !== 'undefined' &&
      canvas instanceof HTMLElement)
  {
    g.pixelratio = (s = pixelRatio(canvas) || 1);
  }

  g.setTransform(s, 0, 0, s, s*p.left, s*p.top);
  return canvas;
}

function pixelRatio(canvas) {
  var g = canvas.getContext('2d');

  // get canvas pixel data
  var devicePixelRatio = window && window.devicePixelRatio || 1,
      backingStoreRatio = (
        g.webkitBackingStorePixelRatio ||
        g.mozBackingStorePixelRatio ||
        g.msBackingStorePixelRatio ||
        g.oBackingStorePixelRatio ||
        g.backingStorePixelRatio) || 1,
      ratio = devicePixelRatio / backingStoreRatio;

  if (devicePixelRatio !== backingStoreRatio) {
    // set actual and visible canvas size
    var w = canvas.width,
        h = canvas.height;
    canvas.width = w * ratio;
    canvas.height = h * ratio;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
  }

  return ratio;
}

function lineDash(canvas) {
  var g = canvas.getContext('2d');
  if (g.vgLineDash) return; // already initialized!

  var NOOP = function() {},
      NODASH = [];
  
  if (g.setLineDash) {
    g.vgLineDash = function(dash) { this.setLineDash(dash || NODASH); };
    g.vgLineDashOffset = function(off) { this.lineDashOffset = off; };
  } else if (g.webkitLineDash !== undefined) {
  	g.vgLineDash = function(dash) { this.webkitLineDash = dash || NODASH; };
    g.vgLineDashOffset = function(off) { this.webkitLineDashOffset = off; };
  } else if (g.mozDash !== undefined) {
    g.vgLineDash = function(dash) { this.mozDash = dash; };
    g.vgLineDashOffset = NOOP;
  } else {
    g.vgLineDash = NOOP;
    g.vgLineDashOffset = NOOP;
  }
  return canvas;
}

module.exports = {
  instance:   instance,
  resize:     resize,
  lineDash:   lineDash
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],38:[function(require,module,exports){
// create a new DOM element
function create(doc, tag, ns) {
  return ns ? doc.createElementNS(ns, tag) : doc.createElement(tag);
}

// remove element from DOM
// recursively remove parent elements if empty
function remove(el) {
  if (!el) return;
  var p = el.parentNode;
  if (p) {
    p.removeChild(el);
    if (!p.childNodes || !p.childNodes.length) remove(p);
  }
}

module.exports = {
  // find first child element with matching tag
  find: function(el, tag) {
    tag = tag.toLowerCase();
    for (var i=0, n=el.childNodes.length; i<n; ++i) {
      if (el.childNodes[i].tagName.toLowerCase() === tag) {
        return el.childNodes[i];
      }
    }
  },
  // retrieve child element at given index
  // create & insert if doesn't exist or if tag/className do not match
  child: function(el, index, tag, ns, className, insert) {
    var a, b;
    a = b = el.childNodes[index];
    if (!a || insert ||
        a.tagName.toLowerCase() !== tag.toLowerCase() ||
        className && a.getAttribute('class') != className) {
      a = create(el.ownerDocument, tag, ns);
      el.insertBefore(a, b);
      if (className) a.setAttribute('class', className);
    }
    return a;
  },
  // remove all child elements at or above the given index
  clear: function(el, index) {
    var curr = el.childNodes.length;
    while (curr > index) {
      el.removeChild(el.childNodes[--curr]);
    }
    return el;
  },
  remove: remove,
  // generate css class name for mark
  cssClass: function(mark) {
    return 'mark-' + mark.marktype + (mark.name ? ' '+mark.name : '');
  },
  // generate string for an opening xml tag
  // tag: the name of the xml tag
  // attr: hash of attribute name-value pairs to include
  // raw: additional raw string to include in tag markup
  openTag: function(tag, attr, raw) {
    var s = '<' + tag, key, val;
    if (attr) {
      for (key in attr) {
        val = attr[key];
        if (val != null) {
          s += ' ' + key + '="' + val + '"';
        }
      }
    }
    if (raw) s += ' ' + raw;
    return s + '>';
  },
  // generate string for closing xml tag
  // tag: the name of the xml tag
  closeTag: function(tag) {
    return '</' + tag + '>';
  }
};

},{}],39:[function(require,module,exports){
var bound = require('../util/bound');

var sets = [
  'items',
  'axisItems',
  'legendItems'
];

var keys = [
  'marktype', 'name', 'interactive', 'clip',
  'items', 'axisItems', 'legendItems', 'layer',
  'x', 'y', 'width', 'height', 'align', 'baseline',             // layout
  'fill', 'fillOpacity', 'opacity',                             // fill
  'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',        // stroke
  'strokeDash', 'strokeDashOffset',                             // stroke dash
  'startAngle', 'endAngle', 'innerRadius', 'outerRadius',       // arc
  'interpolate', 'tension', 'orient',                           // area, line
  'url',                                                        // image
  'path',                                                       // path
  'x2', 'y2',                                                   // rule
  'size', 'shape',                                              // symbol
  'text', 'angle', 'theta', 'radius', 'dx', 'dy',               // text
  'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant'  // font
];

function toJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}

function fromJSON(json) {
  var scene = (typeof json === 'string' ? JSON.parse(json) : json);
  return initialize(scene);
}

function initialize(scene) {
  var type = scene.marktype,
      i, n, s, m, items;

  for (s=0, m=sets.length; s<m; ++s) {
    if ((items = scene[sets[s]])) {
      for (i=0, n=items.length; i<n; ++i) {
        items[i][type ? 'mark' : 'group'] = scene;
        if (!type || type === 'group') {
          initialize(items[i]);
        }
      }
    }
  }

  if (type) bound.mark(scene);
  return scene;
}

module.exports = {
  toJSON:   toJSON,
  fromJSON: fromJSON
};
},{"../util/bound":36}],40:[function(require,module,exports){
(function (global){
var d3_svg = (typeof window !== "undefined" ? window['d3'] : typeof global !== "undefined" ? global['d3'] : null).svg;

function x(o)     { return o.x || 0; }
function y(o)     { return o.y || 0; }
function xw(o)    { return (o.x || 0) + (o.width || 0); }
function yh(o)    { return (o.y || 0) + (o.height || 0); }
function size(o)  { return o.size == null ? 100 : o.size; }
function shape(o) { return o.shape || 'circle'; }

var areav = d3_svg.area().x(x).y1(y).y0(yh),
    areah = d3_svg.area().y(y).x1(x).x0(xw),
    line  = d3_svg.line().x(x).y(y);

module.exports = {
  metadata: {
    'version': '1.1',
    'xmlns': 'http://www.w3.org/2000/svg',
    'xmlns:xlink': 'http://www.w3.org/1999/xlink'
  },
  path: {
    arc: d3_svg.arc(),
    symbol: d3_svg.symbol().type(shape).size(size),
    area: function(items) {
      var o = items[0];
      return (o.orient === 'horizontal' ? areah : areav)
        .interpolate(o.interpolate || 'linear')
        .tension(o.tension || 0.7)
        (items);
    },
    line: function(items) {
      var o = items[0];
      return line
        .interpolate(o.interpolate || 'linear')
        .tension(o.tension || 0.7)
        (items);
    }
  },
  textAlign: {
    'left':   'start',
    'center': 'middle',
    'right':  'end'
  },
  textBaseline: {
    'top':    'before-edge',
    'bottom': 'after-edge',
    'middle': 'central'
  },
  styles: {
    'fill':             'fill',
    'fillOpacity':      'fill-opacity',
    'stroke':           'stroke',
    'strokeWidth':      'stroke-width',
    'strokeOpacity':    'stroke-opacity',
    'strokeCap':        'stroke-linecap',
    'strokeDash':       'stroke-dasharray',
    'strokeDashOffset': 'stroke-dashoffset',
    'opacity':          'opacity'
  },
  styleProperties: [
    'fill',
    'fillOpacity',
    'stroke',
    'strokeWidth',
    'strokeOpacity',
    'strokeCap',
    'strokeDash',
    'strokeDashOffset',
    'opacity'
  ]
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],41:[function(require,module,exports){
function size(item) {
  return item.fontSize != null ? item.fontSize : 11;
}

module.exports = {
  size: size,
  value: function(s) {
    return s != null ? String(s) : '';
  },
  font: function(item, quote) {
    var font = item.font;
    if (quote && font) {
      font = String(font).replace(/\"/g, '\'');
    }
    return '' +
      (item.fontStyle ? item.fontStyle + ' ' : '') +
      (item.fontVariant ? item.fontVariant + ' ' : '') +
      (item.fontWeight ? item.fontWeight + ' ' : '') +
      size(item) + 'px ' +
      (font || 'sans-serif');
  },
  offset: function(item) {
    // perform our own font baseline calculation
    // why? not all browsers support SVG 1.1 'alignment-baseline' :(
    var baseline = item.baseline,
        h = size(item);
    return Math.round(
      baseline === 'top'    ?  0.93*h :
      baseline === 'middle' ?  0.30*h :
      baseline === 'bottom' ? -0.21*h : 0
    );
  }
};

},{}]},{},[3])(3)
});
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9sb2FkLmpzIiwic3JjL2luZGV4LmpzIiwic3JjL3BhdGgvYXJjLmpzIiwic3JjL3BhdGgvaW5kZXguanMiLCJzcmMvcGF0aC9wYXJzZS5qcyIsInNyYy9wYXRoL3JlbmRlci5qcyIsInNyYy9yZW5kZXIvSGFuZGxlci5qcyIsInNyYy9yZW5kZXIvUmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9DYW52YXNIYW5kbGVyLmpzIiwic3JjL3JlbmRlci9jYW52YXMvQ2FudmFzUmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9pbmRleC5qcyIsInNyYy9yZW5kZXIvY2FudmFzL21hcmtzL2FyYy5qcyIsInNyYy9yZW5kZXIvY2FudmFzL21hcmtzL2FyZWEuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9tYXJrcy9ncm91cC5qcyIsInNyYy9yZW5kZXIvY2FudmFzL21hcmtzL2ltYWdlLmpzIiwic3JjL3JlbmRlci9jYW52YXMvbWFya3MvaW5kZXguanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9tYXJrcy9saW5lLmpzIiwic3JjL3JlbmRlci9jYW52YXMvbWFya3MvcGF0aC5qcyIsInNyYy9yZW5kZXIvY2FudmFzL21hcmtzL3JlY3QuanMiLCJzcmMvcmVuZGVyL2NhbnZhcy9tYXJrcy9ydWxlLmpzIiwic3JjL3JlbmRlci9jYW52YXMvbWFya3Mvc3ltYm9sLmpzIiwic3JjL3JlbmRlci9jYW52YXMvbWFya3MvdGV4dC5qcyIsInNyYy9yZW5kZXIvY2FudmFzL21hcmtzL3V0aWwuanMiLCJzcmMvcmVuZGVyL2luZGV4LmpzIiwic3JjL3JlbmRlci9zdmcvU1ZHSGFuZGxlci5qcyIsInNyYy9yZW5kZXIvc3ZnL1NWR1JlbmRlcmVyLmpzIiwic3JjL3JlbmRlci9zdmcvU1ZHU3RyaW5nUmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyL3N2Zy9pbmRleC5qcyIsInNyYy9yZW5kZXIvc3ZnL21hcmtzLmpzIiwic3JjL3V0aWwvQm91bmRzLmpzIiwic3JjL3V0aWwvQm91bmRzQ29udGV4dC5qcyIsInNyYy91dGlsL0dyYWRpZW50LmpzIiwic3JjL3V0aWwvSW1hZ2VMb2FkZXIuanMiLCJzcmMvdXRpbC9JdGVtLmpzIiwic3JjL3V0aWwvYm91bmQuanMiLCJzcmMvdXRpbC9jYW52YXMuanMiLCJzcmMvdXRpbC9kb20uanMiLCJzcmMvdXRpbC9zY2VuZS5qcyIsInNyYy91dGlsL3N2Zy5qcyIsInNyYy91dGlsL3RleHQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2YUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsbnVsbCwiLy8gTWF0Y2hlcyBhYnNvbHV0ZSBVUkxzIHdpdGggb3B0aW9uYWwgcHJvdG9jb2xcbi8vICAgaHR0cHM6Ly8uLi4gICAgZmlsZTovLy4uLiAgICAvLy4uLlxudmFyIHByb3RvY29sX3JlID0gL14oW0EtWmEtel0rOik/XFwvXFwvLztcblxuLy8gU3BlY2lhbCB0cmVhdG1lbnQgaW4gbm9kZS5qcyBmb3IgdGhlIGZpbGU6IHByb3RvY29sXG52YXIgZmlsZVByb3RvY29sID0gJ2ZpbGU6Ly8nO1xuXG4vLyBWYWxpZGF0ZSBhbmQgY2xlYW51cCBVUkwgdG8gZW5zdXJlIHRoYXQgaXQgaXMgYWxsb3dlZCB0byBiZSBhY2Nlc3NlZFxuLy8gUmV0dXJucyBjbGVhbmVkIHVwIFVSTCwgb3IgZmFsc2UgaWYgYWNjZXNzIGlzIG5vdCBhbGxvd2VkXG5mdW5jdGlvbiBzYW5pdGl6ZVVybChvcHQpIHtcbiAgdmFyIHVybCA9IG9wdC51cmw7XG4gIGlmICghdXJsICYmIG9wdC5maWxlKSB7IHJldHVybiBmaWxlUHJvdG9jb2wgKyBvcHQuZmlsZTsgfVxuXG4gIC8vIEluIGNhc2UgdGhpcyBpcyBhIHJlbGF0aXZlIHVybCAoaGFzIG5vIGhvc3QpLCBwcmVwZW5kIG9wdC5iYXNlVVJMXG4gIGlmIChvcHQuYmFzZVVSTCAmJiAhcHJvdG9jb2xfcmUudGVzdCh1cmwpKSB7XG4gICAgaWYgKCFzdGFydHNXaXRoKHVybCwgJy8nKSAmJiBvcHQuYmFzZVVSTFtvcHQuYmFzZVVSTC5sZW5ndGgtMV0gIT09ICcvJykge1xuICAgICAgdXJsID0gJy8nICsgdXJsOyAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyBhIHNsYXNoIGJldHdlZW4gdGhlIGJhc2VVUkwgKGUuZy4gaG9zdG5hbWUpIGFuZCB1cmxcbiAgICB9XG4gICAgdXJsID0gb3B0LmJhc2VVUkwgKyB1cmw7XG4gIH1cbiAgLy8gcmVsYXRpdmUgcHJvdG9jb2wsIHN0YXJ0cyB3aXRoICcvLydcbiAgaWYgKCFsb2FkLnVzZVhIUiAmJiBzdGFydHNXaXRoKHVybCwgJy8vJykpIHtcbiAgICB1cmwgPSAob3B0LmRlZmF1bHRQcm90b2NvbCB8fCAnaHR0cCcpICsgJzonICsgdXJsO1xuICB9XG4gIC8vIElmIG9wdC5kb21haW5XaGl0ZUxpc3QgaXMgc2V0LCBvbmx5IGFsbG93cyB1cmwsIHdob3NlIGhvc3RuYW1lXG4gIC8vICogSXMgdGhlIHNhbWUgYXMgdGhlIG9yaWdpbiAod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKVxuICAvLyAqIEVxdWFscyBvbmUgb2YgdGhlIHZhbHVlcyBpbiB0aGUgd2hpdGVsaXN0XG4gIC8vICogSXMgYSBwcm9wZXIgc3ViZG9tYWluIG9mIG9uZSBvZiB0aGUgdmFsdWVzIGluIHRoZSB3aGl0ZWxpc3RcbiAgaWYgKG9wdC5kb21haW5XaGl0ZUxpc3QpIHtcbiAgICB2YXIgZG9tYWluLCBvcmlnaW47XG4gICAgaWYgKGxvYWQudXNlWEhSKSB7XG4gICAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgIC8vIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MzY1MTMvaG93LWRvLWktcGFyc2UtYS11cmwtaW50by1ob3N0bmFtZS1hbmQtcGF0aC1pbi1qYXZhc2NyaXB0XG4gICAgICAvLyBJRSBkb2Vzbid0IHBvcHVsYXRlIGFsbCBsaW5rIHByb3BlcnRpZXMgd2hlbiBzZXR0aW5nIC5ocmVmIHdpdGggYSByZWxhdGl2ZSBVUkwsXG4gICAgICAvLyBob3dldmVyIC5ocmVmIHdpbGwgcmV0dXJuIGFuIGFic29sdXRlIFVSTCB3aGljaCB0aGVuIGNhbiBiZSB1c2VkIG9uIGl0c2VsZlxuICAgICAgLy8gdG8gcG9wdWxhdGUgdGhlc2UgYWRkaXRpb25hbCBmaWVsZHMuXG4gICAgICBpZiAoYS5ob3N0ID09PSAnJykge1xuICAgICAgICBhLmhyZWYgPSBhLmhyZWY7XG4gICAgICB9XG4gICAgICBkb21haW4gPSBhLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHJlbGF0aXZlIHByb3RvY29sIGlzIGJyb2tlbjogaHR0cHM6Ly9naXRodWIuY29tL2RlZnVuY3R6b21iaWUvbm9kZS11cmwvaXNzdWVzLzVcbiAgICAgIHZhciBwYXJ0cyA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlKHVybCk7XG4gICAgICBkb21haW4gPSBwYXJ0cy5ob3N0bmFtZTtcbiAgICAgIG9yaWdpbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG9yaWdpbiAhPT0gZG9tYWluKSB7XG4gICAgICB2YXIgd2hpdGVMaXN0ZWQgPSBvcHQuZG9tYWluV2hpdGVMaXN0LnNvbWUoZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgaWR4ID0gZG9tYWluLmxlbmd0aCAtIGQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gZCA9PT0gZG9tYWluIHx8XG4gICAgICAgICAgKGlkeCA+IDEgJiYgZG9tYWluW2lkeC0xXSA9PT0gJy4nICYmIGRvbWFpbi5sYXN0SW5kZXhPZihkKSA9PT0gaWR4KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF3aGl0ZUxpc3RlZCkge1xuICAgICAgICB0aHJvdyAnVVJMIGlzIG5vdCB3aGl0ZWxpc3RlZDogJyArIHVybDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuZnVuY3Rpb24gbG9hZChvcHQsIGNhbGxiYWNrKSB7XG4gIHZhciBlcnJvciA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKGUpIHsgdGhyb3cgZTsgfSwgdXJsO1xuXG4gIHRyeSB7XG4gICAgdXJsID0gbG9hZC5zYW5pdGl6ZVVybChvcHQpOyAvLyBlbmFibGUgb3ZlcnJpZGVcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IoZXJyKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXVybCkge1xuICAgIGVycm9yKCdJbnZhbGlkIFVSTDogJyArIG9wdC51cmwpO1xuICB9IGVsc2UgaWYgKGxvYWQudXNlWEhSKSB7XG4gICAgLy8gb24gY2xpZW50LCB1c2UgeGhyXG4gICAgcmV0dXJuIHhocih1cmwsIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmIChzdGFydHNXaXRoKHVybCwgZmlsZVByb3RvY29sKSkge1xuICAgIC8vIG9uIHNlcnZlciwgaWYgdXJsIHN0YXJ0cyB3aXRoICdmaWxlOi8vJywgc3RyaXAgaXQgYW5kIGxvYWQgZnJvbSBmaWxlXG4gICAgcmV0dXJuIGZpbGUodXJsLnNsaWNlKGZpbGVQcm90b2NvbC5sZW5ndGgpLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAodXJsLmluZGV4T2YoJzovLycpIDwgMCkgeyAvLyBUT0RPIGJldHRlciBwcm90b2NvbCBjaGVjaz9cbiAgICAvLyBvbiBzZXJ2ZXIsIGlmIG5vIHByb3RvY29sIGFzc3VtZSBmaWxlXG4gICAgcmV0dXJuIGZpbGUodXJsLCBjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZm9yIHJlZ3VsYXIgVVJMcyBvbiBzZXJ2ZXJcbiAgICByZXR1cm4gaHR0cCh1cmwsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB4aHJIYXNSZXNwb25zZShyZXF1ZXN0KSB7XG4gIHZhciB0eXBlID0gcmVxdWVzdC5yZXNwb25zZVR5cGU7XG4gIHJldHVybiB0eXBlICYmIHR5cGUgIT09ICd0ZXh0JyA/XG4gICAgcmVxdWVzdC5yZXNwb25zZSA6IC8vIG51bGwgb24gZXJyb3JcbiAgICByZXF1ZXN0LnJlc3BvbnNlVGV4dDsgLy8gJycgb24gZXJyb3Jcbn1cblxuZnVuY3Rpb24geGhyKHVybCwgY2FsbGJhY2spIHtcbiAgdmFyIGFzeW5jID0gISFjYWxsYmFjaztcbiAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgLy8gSWYgSUUgZG9lcyBub3Qgc3VwcG9ydCBDT1JTLCB1c2UgWERvbWFpblJlcXVlc3QgKGNvcGllZCBmcm9tIGQzLnhocilcbiAgaWYgKHRoaXMuWERvbWFpblJlcXVlc3QgJiZcbiAgICAgICEoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkgJiZcbiAgICAgIC9eKGh0dHAocyk/Oik/XFwvXFwvLy50ZXN0KHVybCkpIHJlcXVlc3QgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcblxuICBmdW5jdGlvbiByZXNwb25kKCkge1xuICAgIHZhciBzdGF0dXMgPSByZXF1ZXN0LnN0YXR1cztcbiAgICBpZiAoIXN0YXR1cyAmJiB4aHJIYXNSZXNwb25zZShyZXF1ZXN0KSB8fCBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgcmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayhyZXF1ZXN0LCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBpZiAoYXN5bmMpIHtcbiAgICBpZiAoJ29ubG9hZCcgaW4gcmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5vbmxvYWQgPSByZXF1ZXN0Lm9uZXJyb3IgPSByZXNwb25kO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID4gMykgcmVzcG9uZCgpO1xuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgXG4gIHJlcXVlc3Qub3BlbignR0VUJywgdXJsLCBhc3luYyk7XG4gIHJlcXVlc3Quc2VuZCgpO1xuICBcbiAgaWYgKCFhc3luYyAmJiB4aHJIYXNSZXNwb25zZShyZXF1ZXN0KSkge1xuICAgIHJldHVybiByZXF1ZXN0LnJlc3BvbnNlVGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWxlKGZpbGVuYW1lLCBjYWxsYmFjaykge1xuICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSwgJ3V0ZjgnKTtcbiAgfVxuICBmcy5yZWFkRmlsZShmaWxlbmFtZSwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBodHRwKHVybCwgY2FsbGJhY2spIHtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiByZXF1aXJlKCdzeW5jLXJlcXVlc3QnKSgnR0VUJywgdXJsKS5nZXRCb2R5KCk7XG4gIH1cbiAgXG4gIHZhciBvcHRpb25zID0ge3VybDogdXJsLCBlbmNvZGluZzogbnVsbCwgZ3ppcDogdHJ1ZX07XG4gIHJlcXVpcmUoJ3JlcXVlc3QnKShvcHRpb25zLCBmdW5jdGlvbihlcnJvciwgcmVzcG9uc2UsIGJvZHkpIHtcbiAgICBpZiAoIWVycm9yICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgY2FsbGJhY2sobnVsbCwgYm9keSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yID0gZXJyb3IgfHxcbiAgICAgICAgJ0xvYWQgZmFpbGVkIHdpdGggcmVzcG9uc2UgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzQ29kZSArICcuJztcbiAgICAgIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0cmluZywgc2VhcmNoU3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcgPT0gbnVsbCA/IGZhbHNlIDogc3RyaW5nLmxhc3RJbmRleE9mKHNlYXJjaFN0cmluZywgMCkgPT09IDA7XG59XG5cbmxvYWQuc2FuaXRpemVVcmwgPSBzYW5pdGl6ZVVybDtcblxubG9hZC51c2VYSFIgPSAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9hZDtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXRoOiAgICAgICByZXF1aXJlKCcuL3BhdGgnKSxcbiAgcmVuZGVyOiAgICAgcmVxdWlyZSgnLi9yZW5kZXInKSxcbiAgSXRlbTogICAgICAgcmVxdWlyZSgnLi91dGlsL0l0ZW0nKSxcbiAgYm91bmQ6ICAgICAgcmVxdWlyZSgnLi91dGlsL2JvdW5kJyksXG4gIEJvdW5kczogICAgIHJlcXVpcmUoJy4vdXRpbC9Cb3VuZHMnKSxcbiAgY2FudmFzOiAgICAgcmVxdWlyZSgnLi91dGlsL2NhbnZhcycpLFxuICBHcmFkaWVudDogICByZXF1aXJlKCcuL3V0aWwvR3JhZGllbnQnKSxcbiAgdG9KU09OOiAgICAgcmVxdWlyZSgnLi91dGlsL3NjZW5lJykudG9KU09OLFxuICBmcm9tSlNPTjogICByZXF1aXJlKCcuL3V0aWwvc2NlbmUnKS5mcm9tSlNPTlxufTsiLCJ2YXIgc2VnbWVudENhY2hlID0ge30sXG4gICAgYmV6aWVyQ2FjaGUgPSB7fSxcbiAgICBqb2luID0gW10uam9pbjtcblxuLy8gQ29waWVkIGZyb20gSW5rc2NhcGUgc3ZndG9wZGYsIHRoYW5rcyFcbmZ1bmN0aW9uIHNlZ21lbnRzKHgsIHksIHJ4LCByeSwgbGFyZ2UsIHN3ZWVwLCByb3RhdGVYLCBveCwgb3kpIHtcbiAgdmFyIGtleSA9IGpvaW4uY2FsbChhcmd1bWVudHMpO1xuICBpZiAoc2VnbWVudENhY2hlW2tleV0pIHtcbiAgICByZXR1cm4gc2VnbWVudENhY2hlW2tleV07XG4gIH1cblxuICB2YXIgdGggPSByb3RhdGVYICogKE1hdGguUEkvMTgwKTtcbiAgdmFyIHNpbl90aCA9IE1hdGguc2luKHRoKTtcbiAgdmFyIGNvc190aCA9IE1hdGguY29zKHRoKTtcbiAgcnggPSBNYXRoLmFicyhyeCk7XG4gIHJ5ID0gTWF0aC5hYnMocnkpO1xuICB2YXIgcHggPSBjb3NfdGggKiAob3ggLSB4KSAqIDAuNSArIHNpbl90aCAqIChveSAtIHkpICogMC41O1xuICB2YXIgcHkgPSBjb3NfdGggKiAob3kgLSB5KSAqIDAuNSAtIHNpbl90aCAqIChveCAtIHgpICogMC41O1xuICB2YXIgcGwgPSAocHgqcHgpIC8gKHJ4KnJ4KSArIChweSpweSkgLyAocnkqcnkpO1xuICBpZiAocGwgPiAxKSB7XG4gICAgcGwgPSBNYXRoLnNxcnQocGwpO1xuICAgIHJ4ICo9IHBsO1xuICAgIHJ5ICo9IHBsO1xuICB9XG5cbiAgdmFyIGEwMCA9IGNvc190aCAvIHJ4O1xuICB2YXIgYTAxID0gc2luX3RoIC8gcng7XG4gIHZhciBhMTAgPSAoLXNpbl90aCkgLyByeTtcbiAgdmFyIGExMSA9IChjb3NfdGgpIC8gcnk7XG4gIHZhciB4MCA9IGEwMCAqIG94ICsgYTAxICogb3k7XG4gIHZhciB5MCA9IGExMCAqIG94ICsgYTExICogb3k7XG4gIHZhciB4MSA9IGEwMCAqIHggKyBhMDEgKiB5O1xuICB2YXIgeTEgPSBhMTAgKiB4ICsgYTExICogeTtcblxuICB2YXIgZCA9ICh4MS14MCkgKiAoeDEteDApICsgKHkxLXkwKSAqICh5MS15MCk7XG4gIHZhciBzZmFjdG9yX3NxID0gMSAvIGQgLSAwLjI1O1xuICBpZiAoc2ZhY3Rvcl9zcSA8IDApIHNmYWN0b3Jfc3EgPSAwO1xuICB2YXIgc2ZhY3RvciA9IE1hdGguc3FydChzZmFjdG9yX3NxKTtcbiAgaWYgKHN3ZWVwID09IGxhcmdlKSBzZmFjdG9yID0gLXNmYWN0b3I7XG4gIHZhciB4YyA9IDAuNSAqICh4MCArIHgxKSAtIHNmYWN0b3IgKiAoeTEteTApO1xuICB2YXIgeWMgPSAwLjUgKiAoeTAgKyB5MSkgKyBzZmFjdG9yICogKHgxLXgwKTtcblxuICB2YXIgdGgwID0gTWF0aC5hdGFuMih5MC15YywgeDAteGMpO1xuICB2YXIgdGgxID0gTWF0aC5hdGFuMih5MS15YywgeDEteGMpO1xuXG4gIHZhciB0aF9hcmMgPSB0aDEtdGgwO1xuICBpZiAodGhfYXJjIDwgMCAmJiBzd2VlcCA9PT0gMSl7XG4gICAgdGhfYXJjICs9IDIgKiBNYXRoLlBJO1xuICB9IGVsc2UgaWYgKHRoX2FyYyA+IDAgJiYgc3dlZXAgPT09IDApIHtcbiAgICB0aF9hcmMgLT0gMiAqIE1hdGguUEk7XG4gIH1cblxuICB2YXIgc2VncyA9IE1hdGguY2VpbChNYXRoLmFicyh0aF9hcmMgLyAoTWF0aC5QSSAqIDAuNSArIDAuMDAxKSkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGk9MDsgaTxzZWdzOyArK2kpIHtcbiAgICB2YXIgdGgyID0gdGgwICsgaSAqIHRoX2FyYyAvIHNlZ3M7XG4gICAgdmFyIHRoMyA9IHRoMCArIChpKzEpICogdGhfYXJjIC8gc2VncztcbiAgICByZXN1bHRbaV0gPSBbeGMsIHljLCB0aDIsIHRoMywgcngsIHJ5LCBzaW5fdGgsIGNvc190aF07XG4gIH1cblxuICByZXR1cm4gKHNlZ21lbnRDYWNoZVtrZXldID0gcmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gYmV6aWVyKHBhcmFtcykge1xuICB2YXIga2V5ID0gam9pbi5jYWxsKHBhcmFtcyk7XG4gIGlmIChiZXppZXJDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIGJlemllckNhY2hlW2tleV07XG4gIH1cbiAgXG4gIHZhciBjeCA9IHBhcmFtc1swXSxcbiAgICAgIGN5ID0gcGFyYW1zWzFdLFxuICAgICAgdGgwID0gcGFyYW1zWzJdLFxuICAgICAgdGgxID0gcGFyYW1zWzNdLFxuICAgICAgcnggPSBwYXJhbXNbNF0sXG4gICAgICByeSA9IHBhcmFtc1s1XSxcbiAgICAgIHNpbl90aCA9IHBhcmFtc1s2XSxcbiAgICAgIGNvc190aCA9IHBhcmFtc1s3XTtcblxuICB2YXIgYTAwID0gY29zX3RoICogcng7XG4gIHZhciBhMDEgPSAtc2luX3RoICogcnk7XG4gIHZhciBhMTAgPSBzaW5fdGggKiByeDtcbiAgdmFyIGExMSA9IGNvc190aCAqIHJ5O1xuXG4gIHZhciBjb3NfdGgwID0gTWF0aC5jb3ModGgwKTtcbiAgdmFyIHNpbl90aDAgPSBNYXRoLnNpbih0aDApO1xuICB2YXIgY29zX3RoMSA9IE1hdGguY29zKHRoMSk7XG4gIHZhciBzaW5fdGgxID0gTWF0aC5zaW4odGgxKTtcblxuICB2YXIgdGhfaGFsZiA9IDAuNSAqICh0aDEgLSB0aDApO1xuICB2YXIgc2luX3RoX2gyID0gTWF0aC5zaW4odGhfaGFsZiAqIDAuNSk7XG4gIHZhciB0ID0gKDgvMykgKiBzaW5fdGhfaDIgKiBzaW5fdGhfaDIgLyBNYXRoLnNpbih0aF9oYWxmKTtcbiAgdmFyIHgxID0gY3ggKyBjb3NfdGgwIC0gdCAqIHNpbl90aDA7XG4gIHZhciB5MSA9IGN5ICsgc2luX3RoMCArIHQgKiBjb3NfdGgwO1xuICB2YXIgeDMgPSBjeCArIGNvc190aDE7XG4gIHZhciB5MyA9IGN5ICsgc2luX3RoMTtcbiAgdmFyIHgyID0geDMgKyB0ICogc2luX3RoMTtcbiAgdmFyIHkyID0geTMgLSB0ICogY29zX3RoMTtcblxuICByZXR1cm4gKGJlemllckNhY2hlW2tleV0gPSBbXG4gICAgYTAwICogeDEgKyBhMDEgKiB5MSwgIGExMCAqIHgxICsgYTExICogeTEsXG4gICAgYTAwICogeDIgKyBhMDEgKiB5MiwgIGExMCAqIHgyICsgYTExICogeTIsXG4gICAgYTAwICogeDMgKyBhMDEgKiB5MywgIGExMCAqIHgzICsgYTExICogeTNcbiAgXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZWdtZW50czogc2VnbWVudHMsXG4gIGJlemllcjogYmV6aWVyLFxuICBjYWNoZToge1xuICAgIHNlZ21lbnRzOiBzZWdtZW50Q2FjaGUsXG4gICAgYmV6aWVyOiBiZXppZXJDYWNoZVxuICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBhcnNlOiAgcmVxdWlyZSgnLi9wYXJzZScpLFxuICByZW5kZXI6IHJlcXVpcmUoJy4vcmVuZGVyJylcbn07XG4iLCIvLyBQYXRoIHBhcnNpbmcgYW5kIHJlbmRlcmluZyBjb2RlIGFkYXB0ZWQgZnJvbSBmYWJyaWMuanMgLS0gVGhhbmtzIVxudmFyIGNtZGxlbiA9IHsgbToyLCBsOjIsIGg6MSwgdjoxLCBjOjYsIHM6NCwgcTo0LCB0OjIsIGE6NyB9LFxuICAgIHJlZ2V4cCA9IFsvKFtNTEhWQ1NRVEFabWxodmNzcXRhel0pL2csIC8jIyMvLCAvKFxcZCkoWy0rXSkvZywgL1xcc3wsfCMjIy9dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBhdGhzdHIpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgcGF0aCxcbiAgICAgIGN1cnIsXG4gICAgICBjaHVua3MsXG4gICAgICBwYXJzZWQsIHBhcmFtLFxuICAgICAgY21kLCBsZW4sIGksIGosIG4sIG07XG5cbiAgLy8gRmlyc3QsIGJyZWFrIHBhdGggaW50byBjb21tYW5kIHNlcXVlbmNlXG4gIHBhdGggPSBwYXRoc3RyXG4gICAgLnNsaWNlKClcbiAgICAucmVwbGFjZShyZWdleHBbMF0sICcjIyMkMScpXG4gICAgLnNwbGl0KHJlZ2V4cFsxXSlcbiAgICAuc2xpY2UoMSk7XG5cbiAgLy8gTmV4dCwgcGFyc2UgZWFjaCBjb21tYW5kIGluIHR1cm5cbiAgZm9yIChpPTAsIG49cGF0aC5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgY3VyciA9IHBhdGhbaV07XG4gICAgY2h1bmtzID0gY3VyclxuICAgICAgLnNsaWNlKDEpXG4gICAgICAudHJpbSgpXG4gICAgICAucmVwbGFjZShyZWdleHBbMl0sJyQxIyMjJDInKVxuICAgICAgLnNwbGl0KHJlZ2V4cFszXSk7XG4gICAgY21kID0gY3Vyci5jaGFyQXQoMCk7XG5cbiAgICBwYXJzZWQgPSBbY21kXTtcbiAgICBmb3IgKGo9MCwgbT1jaHVua3MubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKChwYXJhbSA9ICtjaHVua3Nbal0pID09PSBwYXJhbSkgeyAvLyBub3QgTmFOXG4gICAgICAgIHBhcnNlZC5wdXNoKHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZW4gPSBjbWRsZW5bY21kLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmIChwYXJzZWQubGVuZ3RoLTEgPiBsZW4pIHtcbiAgICAgIGZvciAoaj0xLCBtPXBhcnNlZC5sZW5ndGg7IGo8bTsgais9bGVuKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFtjbWRdLmNvbmNhdChwYXJzZWQuc2xpY2UoaiwgaitsZW4pKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2gocGFyc2VkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBhcmMgPSByZXF1aXJlKCcuL2FyYycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGcsIHBhdGgsIGwsIHQpIHtcbiAgdmFyIGN1cnJlbnQsIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICAgIHByZXZpb3VzID0gbnVsbCxcbiAgICAgIHggPSAwLCAvLyBjdXJyZW50IHhcbiAgICAgIHkgPSAwLCAvLyBjdXJyZW50IHlcbiAgICAgIGNvbnRyb2xYID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHhcbiAgICAgIGNvbnRyb2xZID0gMCwgLy8gY3VycmVudCBjb250cm9sIHBvaW50IHlcbiAgICAgIHRlbXBYLFxuICAgICAgdGVtcFksXG4gICAgICB0ZW1wQ29udHJvbFgsXG4gICAgICB0ZW1wQ29udHJvbFk7XG5cbiAgaWYgKGwgPT0gbnVsbCkgbCA9IDA7XG4gIGlmICh0ID09IG51bGwpIHQgPSAwO1xuXG4gIGcuYmVnaW5QYXRoKCk7XG5cbiAgZm9yICh2YXIgaT0wLCBsZW49cGF0aC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICBjdXJyZW50ID0gcGF0aFtpXTtcblxuICAgIHN3aXRjaCAoY3VycmVudFswXSkgeyAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgY2FzZSAnbCc6IC8vIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdMJzogLy8gbGluZXRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdoJzogLy8gaG9yaXpvbnRhbCBsaW5ldG8sIHJlbGF0aXZlXG4gICAgICAgIHggKz0gY3VycmVudFsxXTtcbiAgICAgICAgZy5saW5lVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0gnOiAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2JzogLy8gdmVydGljYWwgbGluZXRvLCByZWxhdGl2ZVxuICAgICAgICB5ICs9IGN1cnJlbnRbMV07XG4gICAgICAgIGcubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdWJzogLy8gdmVyaWNhbCBsaW5ldG8sIGFic29sdXRlXG4gICAgICAgIHkgPSBjdXJyZW50WzFdO1xuICAgICAgICBnLmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbSc6IC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdNJzogLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGcubW92ZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdjJzogLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFs1XTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCwgLy8geDFcbiAgICAgICAgICB5ICsgY3VycmVudFsyXSArIHQsIC8vIHkxXG4gICAgICAgICAgY29udHJvbFggKyBsLCAvLyB4MlxuICAgICAgICAgIGNvbnRyb2xZICsgdCwgLy8geTJcbiAgICAgICAgICB0ZW1wWCArIGwsXG4gICAgICAgICAgdGVtcFkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnQyc6IC8vIGJlemllckN1cnZlVG8sIGFic29sdXRlXG4gICAgICAgIHggPSBjdXJyZW50WzVdO1xuICAgICAgICB5ID0gY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzNdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzJdICsgdCxcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHggKyBsLFxuICAgICAgICAgIHkgKyB0XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdzJzogLy8gc2hvcnRoYW5kIGN1YmljIGJlemllckN1cnZlVG8sIHJlbGF0aXZlXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0byBhYnNvbHV0ZSB4LHlcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyICogeCAtIGNvbnRyb2xYO1xuICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIGcuYmV6aWVyQ3VydmVUbyhcbiAgICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgICAgY29udHJvbFkgKyB0LFxuICAgICAgICAgIHggKyBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgICB5ICsgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHNldCBjb250cm9sIHBvaW50IHRvIDJuZCBvbmUgb2YgdGhpcyBjb21tYW5kXG4gICAgICAgIC8vIHRoZSBmaXJzdCBjb250cm9sIHBvaW50IGlzIGFzc3VtZWQgdG8gYmUgdGhlIHJlZmxlY3Rpb24gb2ZcbiAgICAgICAgLy8gdGhlIHNlY29uZCBjb250cm9sIHBvaW50IG9uIHRoZSBwcmV2aW91cyBjb21tYW5kIHJlbGF0aXZlXG4gICAgICAgIC8vIHRvIHRoZSBjdXJyZW50IHBvaW50LlxuICAgICAgICBjb250cm9sWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnUyc6IC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcbiAgICAgICAgLy8gY2FsY3VsYXRlIHJlZmxlY3Rpb24gb2YgcHJldmlvdXMgY29udHJvbCBwb2ludHNcbiAgICAgICAgY29udHJvbFggPSAyKnggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyKnkgLSBjb250cm9sWTtcbiAgICAgICAgZy5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZlxuICAgICAgICAvLyB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmVcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdxJzogLy8gcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzRdO1xuXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG5cbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1EnOiAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0gY3VycmVudFs0XTtcblxuICAgICAgICBnLnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgY3VycmVudFsxXSArIGwsXG4gICAgICAgICAgY3VycmVudFsyXSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250cm9sWSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd0JzogLy8gc2hvcnRoYW5kIHF1YWRyYXRpY0N1cnZlVG8sIHJlbGF0aXZlXG5cbiAgICAgICAgLy8gdHJhbnNmb3JtIHRvIGFic29sdXRlIHgseVxuICAgICAgICB0ZW1wWCA9IHggKyBjdXJyZW50WzFdO1xuICAgICAgICB0ZW1wWSA9IHkgKyBjdXJyZW50WzJdO1xuXG4gICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICd0Jykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciB0XG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIHRlbXBDb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gdGVtcENvbnRyb2xZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAncScpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgcVxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZW1wQ29udHJvbFggPSBjb250cm9sWDtcbiAgICAgICAgdGVtcENvbnRyb2xZID0gY29udHJvbFk7XG5cbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFsyXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ1QnOlxuICAgICAgICB0ZW1wWCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0gY3VycmVudFsyXTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50c1xuICAgICAgICBjb250cm9sWCA9IDIgKiB4IC0gY29udHJvbFg7XG4gICAgICAgIGNvbnRyb2xZID0gMiAqIHkgLSBjb250cm9sWTtcbiAgICAgICAgZy5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgIGNvbnRyb2xYICsgbCxcbiAgICAgICAgICBjb250cm9sWSArIHQsXG4gICAgICAgICAgdGVtcFggKyBsLFxuICAgICAgICAgIHRlbXBZICsgdFxuICAgICAgICApO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICBkcmF3QXJjKGcsIHggKyBsLCB5ICsgdCwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdICsgeCArIGwsXG4gICAgICAgICAgY3VycmVudFs3XSArIHkgKyB0XG4gICAgICAgIF0pO1xuICAgICAgICB4ICs9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgKz0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0EnOlxuICAgICAgICBkcmF3QXJjKGcsIHggKyBsLCB5ICsgdCwgW1xuICAgICAgICAgIGN1cnJlbnRbMV0sXG4gICAgICAgICAgY3VycmVudFsyXSxcbiAgICAgICAgICBjdXJyZW50WzNdLFxuICAgICAgICAgIGN1cnJlbnRbNF0sXG4gICAgICAgICAgY3VycmVudFs1XSxcbiAgICAgICAgICBjdXJyZW50WzZdICsgbCxcbiAgICAgICAgICBjdXJyZW50WzddICsgdFxuICAgICAgICBdKTtcbiAgICAgICAgeCA9IGN1cnJlbnRbNl07XG4gICAgICAgIHkgPSBjdXJyZW50WzddO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAneic6XG4gICAgICBjYXNlICdaJzpcbiAgICAgICAgZy5jbG9zZVBhdGgoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZpb3VzID0gY3VycmVudDtcbiAgfVxufTtcblxuZnVuY3Rpb24gZHJhd0FyYyhnLCB4LCB5LCBjb29yZHMpIHtcbiAgdmFyIHNlZyA9IGFyYy5zZWdtZW50cyhcbiAgICBjb29yZHNbNV0sIC8vIGVuZCB4XG4gICAgY29vcmRzWzZdLCAvLyBlbmQgeVxuICAgIGNvb3Jkc1swXSwgLy8gcmFkaXVzIHhcbiAgICBjb29yZHNbMV0sIC8vIHJhZGl1cyB5XG4gICAgY29vcmRzWzNdLCAvLyBsYXJnZSBmbGFnXG4gICAgY29vcmRzWzRdLCAvLyBzd2VlcCBmbGFnXG4gICAgY29vcmRzWzJdLCAvLyByb3RhdGlvblxuICAgIHgsIHlcbiAgKTtcbiAgZm9yICh2YXIgaT0wOyBpPHNlZy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBiZXogPSBhcmMuYmV6aWVyKHNlZ1tpXSk7XG4gICAgZy5iZXppZXJDdXJ2ZVRvLmFwcGx5KGcsIGJleik7XG4gIH1cbn1cbiIsImZ1bmN0aW9uIEhhbmRsZXIoKSB7XG4gIHRoaXMuX2FjdGl2ZSA9IG51bGw7XG4gIHRoaXMuX2hhbmRsZXJzID0ge307XG59XG5cbnZhciBwcm90b3R5cGUgPSBIYW5kbGVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgcGFkLCBvYmopIHtcbiAgdGhpcy5fZWwgPSBlbDtcbiAgdGhpcy5fb2JqID0gb2JqIHx8IG51bGw7XG4gIHJldHVybiB0aGlzLnBhZGRpbmcocGFkKTtcbn07XG5cbnByb3RvdHlwZS5lbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9lbDtcbn07XG5cbnByb3RvdHlwZS5wYWRkaW5nID0gZnVuY3Rpb24ocGFkKSB7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWQgfHwge3RvcDowLCBsZWZ0OjAsIGJvdHRvbTowLCByaWdodDowfTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuc2NlbmUgPSBmdW5jdGlvbihzY2VuZSkge1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zY2VuZTtcbiAgdGhpcy5fc2NlbmUgPSBzY2VuZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBhZGQgYW4gZXZlbnQgaGFuZGxlclxuLy8gc3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcbnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKC8qdHlwZSwgaGFuZGxlciovKSB7fTtcblxuLy8gcmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbi8vIHN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oLyp0eXBlLCBoYW5kbGVyKi8pIHt9O1xuXG4vLyByZXR1cm4gYW4gYXJyYXkgd2l0aCBhbGwgcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVyc1xucHJvdG90eXBlLmhhbmRsZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBoID0gdGhpcy5faGFuZGxlcnMsIGEgPSBbXSwgaztcbiAgZm9yIChrIGluIGgpIHsgYS5wdXNoLmFwcGx5KGEsIGhba10pOyB9XG4gIHJldHVybiBhO1xufTtcblxucHJvdG90eXBlLmV2ZW50TmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGkgPSBuYW1lLmluZGV4T2YoJy4nKTtcbiAgcmV0dXJuIGkgPCAwID8gbmFtZSA6IG5hbWUuc2xpY2UoMCxpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSGFuZGxlcjsiLCJmdW5jdGlvbiBSZW5kZXJlcigpIHtcbiAgdGhpcy5fZWwgPSBudWxsO1xuICB0aGlzLl9iZ2NvbG9yID0gbnVsbDtcbn1cblxudmFyIHByb3RvdHlwZSA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgd2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICB0aGlzLl9lbCA9IGVsO1xuICByZXR1cm4gdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCwgcGFkZGluZyk7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSBwYXJlbnQgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgdmlzdWFsaXphdGlvblxucHJvdG90eXBlLmVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VsO1xufTtcblxuLy8gUmV0dXJucyB0aGUgc2NlbmUgZWxlbWVudCAoZS5nLiwgY2FudmFzIG9yIFNWRykgb2YgdGhlIHZpc3VhbGl6YXRpb25cbi8vIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSBpZiB0aGUgZmlyc3QgY2hpbGQgaXMgbm90IHRoZSBzY2VuZSBlbGVtZW50XG5wcm90b3R5cGUuc2NlbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2VsICYmIHRoaXMuX2VsLmZpcnN0Q2hpbGQ7XG59O1xuXG5wcm90b3R5cGUuYmFja2dyb3VuZCA9IGZ1bmN0aW9uKGJnY29sb3IpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9iZ2NvbG9yO1xuICB0aGlzLl9iZ2NvbG9yID0gYmdjb2xvcjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nIHx8IHt0b3A6MCwgbGVmdDowLCBib3R0b206MCwgcmlnaHQ6MH07XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKC8qc2NlbmUsIGl0ZW1zKi8pIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbmRlcmVyOyIsInZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIEhhbmRsZXIgPSByZXF1aXJlKCcuLi9IYW5kbGVyJyksXG4gICAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbmZ1bmN0aW9uIENhbnZhc0hhbmRsZXIoKSB7XG4gIEhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5fZG93biA9IG51bGw7XG4gIHRoaXMuX3RvdWNoID0gbnVsbDtcbiAgdGhpcy5fZmlyc3QgPSB0cnVlO1xufVxuXG52YXIgYmFzZSA9IEhhbmRsZXIucHJvdG90eXBlO1xudmFyIHByb3RvdHlwZSA9IChDYW52YXNIYW5kbGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzSGFuZGxlcjtcblxucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbihlbCwgcGFkLCBvYmopIHtcbiAgLy8gYWRkIGV2ZW50IGxpc3RlbmVyc1xuICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzID0gRE9NLmZpbmQoZWwsICdjYW52YXMnKTtcbiAgaWYgKGNhbnZhcykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAocHJvdG90eXBlW3R5cGVdKSB7XG4gICAgICAgICAgcHJvdG90eXBlW3R5cGVdLmNhbGwodGhhdCwgZXZ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0LmZpcmUodHlwZSwgZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gYmFzZS5pbml0aWFsaXplLmNhbGwodGhpcywgZWwsIHBhZCwgb2JqKTtcbn07XG5cbnByb3RvdHlwZS5jYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbn07XG5cbi8vIHJldHJpZXZlIHRoZSBjdXJyZW50IGNhbnZhcyBjb250ZXh0XG5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG59O1xuXG4vLyBzdXBwb3J0ZWQgZXZlbnRzXG5wcm90b3R5cGUuZXZlbnRzID0gW1xuICAna2V5ZG93bicsXG4gICdrZXlwcmVzcycsXG4gICdrZXl1cCcsXG4gICdkcmFnZW50ZXInLFxuICAnZHJhZ2xlYXZlJyxcbiAgJ2RyYWdvdmVyJyxcbiAgJ21vdXNlZG93bicsXG4gICdtb3VzZXVwJyxcbiAgJ21vdXNlbW92ZScsXG4gICdtb3VzZW91dCcsXG4gICdtb3VzZW92ZXInLFxuICAnY2xpY2snLFxuICAnZGJsY2xpY2snLFxuICAnd2hlZWwnLFxuICAnbW91c2V3aGVlbCcsXG4gICd0b3VjaHN0YXJ0JyxcbiAgJ3RvdWNobW92ZScsXG4gICd0b3VjaGVuZCdcbl07XG5cbi8vIHRvIGtlZXAgZmlyZWZveCBoYXBweVxucHJvdG90eXBlLkRPTU1vdXNlU2Nyb2xsID0gZnVuY3Rpb24oZXZ0KSB7XG4gIHRoaXMuZmlyZSgnbW91c2V3aGVlbCcsIGV2dCk7XG59O1xuXG5mdW5jdGlvbiBtb3ZlKG1vdmVFdmVudCwgb3ZlckV2ZW50LCBvdXRFdmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIGEgPSB0aGlzLl9hY3RpdmUsXG4gICAgICAgIHAgPSB0aGlzLnBpY2tFdmVudChldnQpO1xuXG4gICAgaWYgKHAgPT09IGEpIHtcbiAgICAgIC8vIGFjdGl2ZSBpdGVtIGFuZCBwaWNrZWQgaXRlbSBhcmUgdGhlIHNhbWVcbiAgICAgIHRoaXMuZmlyZShtb3ZlRXZlbnQsIGV2dCk7IC8vIGZpcmUgbW92ZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhY3RpdmUgaXRlbSBhbmQgcGlja2VkIGl0ZW0gYXJlIGRpZmZlcmVudFxuICAgICAgdGhpcy5maXJlKG91dEV2ZW50LCBldnQpOyAgLy8gZmlyZSBvdXQgZm9yIHByaW9yIGFjdGl2ZSBpdGVtXG4gICAgICB0aGlzLl9hY3RpdmUgPSBwOyAgICAgICAgICAgIC8vIHNldCBuZXcgYWN0aXZlIGl0ZW1cbiAgICAgIHRoaXMuZmlyZShvdmVyRXZlbnQsIGV2dCk7IC8vIGZpcmUgb3ZlciBmb3IgbmV3IGFjdGl2ZSBpdGVtXG4gICAgICB0aGlzLmZpcmUobW92ZUV2ZW50LCBldnQpOyAvLyBmaXJlIG1vdmUgZm9yIG5ldyBhY3RpdmUgaXRlbVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5hY3RpdmUodHlwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdGhpcy5maXJlKHR5cGUsIGV2dCk7XG4gICAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgfTtcbn1cblxucHJvdG90eXBlLm1vdXNlbW92ZSA9IG1vdmUoJ21vdXNlbW92ZScsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnKTtcbnByb3RvdHlwZS5kcmFnb3ZlciAgPSBtb3ZlKCdkcmFnb3ZlcicsICdkcmFnZW50ZXInLCAnZHJhZ2xlYXZlJyk7XG5cbnByb3RvdHlwZS5tb3VzZW91dCAgPSBpbmFjdGl2ZSgnbW91c2VvdXQnKTtcbnByb3RvdHlwZS5kcmFnbGVhdmUgPSBpbmFjdGl2ZSgnZHJhZ2xlYXZlJyk7XG5cbnByb3RvdHlwZS5tb3VzZWRvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgdGhpcy5fZG93biA9IHRoaXMuX2FjdGl2ZTtcbiAgdGhpcy5maXJlKCdtb3VzZWRvd24nLCBldnQpO1xufTtcblxucHJvdG90eXBlLmNsaWNrID0gZnVuY3Rpb24oZXZ0KSB7XG4gIGlmICh0aGlzLl9kb3duID09PSB0aGlzLl9hY3RpdmUpIHtcbiAgICB0aGlzLmZpcmUoJ2NsaWNrJywgZXZ0KTtcbiAgICB0aGlzLl9kb3duID0gbnVsbDtcbiAgfVxufTtcblxucHJvdG90eXBlLnRvdWNoc3RhcnQgPSBmdW5jdGlvbihldnQpIHtcbiAgdGhpcy5fdG91Y2ggPSB0aGlzLnBpY2tFdmVudChldnQuY2hhbmdlZFRvdWNoZXNbMF0pO1xuXG4gIGlmICh0aGlzLl9maXJzdCkge1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX3RvdWNoO1xuICAgIHRoaXMuX2ZpcnN0ID0gZmFsc2U7XG4gIH1cblxuICB0aGlzLmZpcmUoJ3RvdWNoc3RhcnQnLCBldnQsIHRydWUpO1xufTtcblxucHJvdG90eXBlLnRvdWNobW92ZSA9IGZ1bmN0aW9uKGV2dCkge1xuICB0aGlzLmZpcmUoJ3RvdWNobW92ZScsIGV2dCwgdHJ1ZSk7XG59O1xuXG5wcm90b3R5cGUudG91Y2hlbmQgPSBmdW5jdGlvbihldnQpIHtcbiAgdGhpcy5maXJlKCd0b3VjaGVuZCcsIGV2dCwgdHJ1ZSk7XG4gIHRoaXMuX3RvdWNoID0gbnVsbDtcbn07XG5cbi8vIGZpcmUgYW4gZXZlbnRcbnByb3RvdHlwZS5maXJlID0gZnVuY3Rpb24odHlwZSwgZXZ0LCB0b3VjaCkge1xuICB2YXIgYSA9IHRvdWNoID8gdGhpcy5fdG91Y2ggOiB0aGlzLl9hY3RpdmUsXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnNbdHlwZV0sIGksIGxlbjtcbiAgaWYgKGgpIHtcbiAgICBldnQudmVnYVR5cGUgPSB0eXBlO1xuICAgIGZvciAoaT0wLCBsZW49aC5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICAgIGhbaV0uaGFuZGxlci5jYWxsKHRoaXMuX29iaiwgZXZ0LCBhKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIGFkZCBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub24gPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gdGhpcy5ldmVudE5hbWUodHlwZSksXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnM7XG4gIChoW25hbWVdIHx8IChoW25hbWVdID0gW10pKS5wdXNoKHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIGhhbmRsZXI6IGhhbmRsZXJcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gcmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbih0eXBlLCBoYW5kbGVyKSB7XG4gIHZhciBuYW1lID0gdGhpcy5ldmVudE5hbWUodHlwZSksXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnNbbmFtZV0sIGk7XG4gIGlmICghaCkgcmV0dXJuO1xuICBmb3IgKGk9aC5sZW5ndGg7IC0taT49MDspIHtcbiAgICBpZiAoaFtpXS50eXBlICE9PSB0eXBlKSBjb250aW51ZTtcbiAgICBpZiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSBoLnNwbGljZShpLCAxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5waWNrRXZlbnQgPSBmdW5jdGlvbihldnQpIHtcbiAgdmFyIHJlY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBwYWQgPSB0aGlzLl9wYWRkaW5nLCB4LCB5O1xuICByZXR1cm4gdGhpcy5waWNrKHRoaXMuX3NjZW5lLFxuICAgIHggPSAoZXZ0LmNsaWVudFggLSByZWN0LmxlZnQpLFxuICAgIHkgPSAoZXZ0LmNsaWVudFkgLSByZWN0LnRvcCksXG4gICAgeCAtIHBhZC5sZWZ0LCB5IC0gcGFkLnRvcCk7XG59O1xuXG4vLyBmaW5kIHRoZSBzY2VuZWdyYXBoIGl0ZW0gYXQgdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb25cbi8vIHgsIHkgLS0gdGhlIGFic29sdXRlIHgsIHkgbW91c2UgY29vcmRpbmF0ZXMgb24gdGhlIGNhbnZhcyBlbGVtZW50XG4vLyBneCwgZ3kgLS0gdGhlIHJlbGF0aXZlIGNvb3JkaW5hdGVzIHdpdGhpbiB0aGUgY3VycmVudCBncm91cFxucHJvdG90eXBlLnBpY2sgPSBmdW5jdGlvbihzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIHZhciBnID0gdGhpcy5jb250ZXh0KCksXG4gICAgICBtYXJrID0gbWFya3Nbc2NlbmUubWFya3R5cGVdO1xuICByZXR1cm4gbWFyay5waWNrLmNhbGwodGhpcywgZywgc2NlbmUsIHgsIHksIGd4LCBneSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc0hhbmRsZXI7XG4iLCJ2YXIgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKSxcbiAgICBCb3VuZHMgPSByZXF1aXJlKCcuLi8uLi91dGlsL0JvdW5kcycpLFxuICAgIEltYWdlTG9hZGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9JbWFnZUxvYWRlcicpLFxuICAgIENhbnZhcyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY2FudmFzJyksXG4gICAgUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9SZW5kZXJlcicpLFxuICAgIG1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpO1xuXG5mdW5jdGlvbiBDYW52YXNSZW5kZXJlcihsb2FkQ29uZmlnKSB7XG4gIFJlbmRlcmVyLmNhbGwodGhpcyk7XG4gIHRoaXMuX2xvYWRlciA9IG5ldyBJbWFnZUxvYWRlcihsb2FkQ29uZmlnKTtcbn1cblxuQ2FudmFzUmVuZGVyZXIuUkVUSU5BID0gdHJ1ZTtcblxudmFyIGJhc2UgPSBSZW5kZXJlci5wcm90b3R5cGU7XG52YXIgcHJvdG90eXBlID0gKENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoYmFzZSkpO1xucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2FudmFzUmVuZGVyZXI7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgdGhpcy5fY2FudmFzID0gQ2FudmFzLmluc3RhbmNlKHdpZHRoLCBoZWlnaHQpO1xuICBpZiAoZWwpIHtcbiAgICBET00uY2xlYXIoZWwsIDApLmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XG4gICAgdGhpcy5fY2FudmFzLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbWFya3MnKTtcbiAgfVxuICByZXR1cm4gYmFzZS5pbml0aWFsaXplLmNhbGwodGhpcywgZWwsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xufTtcblxucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgYmFzZS5yZXNpemUuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKTtcbiAgQ2FudmFzLnJlc2l6ZSh0aGlzLl9jYW52YXMsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsXG4gICAgdGhpcy5fcGFkZGluZywgQ2FudmFzUmVuZGVyZXIuUkVUSU5BKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuY2FudmFzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9jYW52YXM7XG59O1xuXG5wcm90b3R5cGUuY29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fY2FudmFzID8gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJykgOiBudWxsO1xufTtcblxucHJvdG90eXBlLnBlbmRpbmdJbWFnZXMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xvYWRlci5wZW5kaW5nKCk7XG59O1xuXG5mdW5jdGlvbiBjbGlwVG9Cb3VuZHMoZywgaXRlbXMpIHtcbiAgaWYgKCFpdGVtcykgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGIgPSBuZXcgQm91bmRzKCksIGksIG4sIGl0ZW0sIG1hcmssIGdyb3VwO1xuICBmb3IgKGk9MCwgbj1pdGVtcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgIG1hcmsgPSBpdGVtLm1hcms7XG4gICAgZ3JvdXAgPSBtYXJrLmdyb3VwO1xuICAgIGl0ZW0gPSBtYXJrc1ttYXJrLm1hcmt0eXBlXS5uZXN0ZWQgPyBtYXJrIDogaXRlbTtcbiAgICBiLnVuaW9uKHRyYW5zbGF0ZShpdGVtLmJvdW5kcywgZ3JvdXApKTtcbiAgICBpZiAoaXRlbVsnYm91bmRzOnByZXYnXSkge1xuICAgICAgYi51bmlvbih0cmFuc2xhdGUoaXRlbVsnYm91bmRzOnByZXYnXSwgZ3JvdXApKTtcbiAgICB9XG4gIH1cbiAgYi5yb3VuZCgpO1xuXG4gIGcuYmVnaW5QYXRoKCk7XG4gIGcucmVjdChiLngxLCBiLnkxLCBiLndpZHRoKCksIGIuaGVpZ2h0KCkpO1xuICBnLmNsaXAoKTtcblxuICByZXR1cm4gYjtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlKGJvdW5kcywgZ3JvdXApIHtcbiAgaWYgKGdyb3VwID09IG51bGwpIHJldHVybiBib3VuZHM7XG4gIHZhciBiID0gYm91bmRzLmNsb25lKCk7XG4gIGZvciAoOyBncm91cCAhPSBudWxsOyBncm91cCA9IGdyb3VwLm1hcmsuZ3JvdXApIHtcbiAgICBiLnRyYW5zbGF0ZShncm91cC54IHx8IDAsIGdyb3VwLnkgfHwgMCk7XG4gIH1cbiAgcmV0dXJuIGI7XG59XG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSwgaXRlbXMpIHtcbiAgdmFyIGcgPSB0aGlzLmNvbnRleHQoKSxcbiAgICAgIHAgPSB0aGlzLl9wYWRkaW5nLFxuICAgICAgdyA9IHRoaXMuX3dpZHRoICsgcC5sZWZ0ICsgcC5yaWdodCxcbiAgICAgIGggPSB0aGlzLl9oZWlnaHQgKyBwLnRvcCArIHAuYm90dG9tLFxuICAgICAgYjtcblxuICAvLyBzZXR1cFxuICB0aGlzLl9zY2VuZSA9IHNjZW5lOyAvLyBjYWNoZSBzY2VuZSBmb3IgYXN5bmMgcmVkcmF3XG4gIGcuc2F2ZSgpO1xuICBiID0gY2xpcFRvQm91bmRzKGcsIGl0ZW1zKTtcbiAgdGhpcy5jbGVhcigtcC5sZWZ0LCAtcC50b3AsIHcsIGgpO1xuXG4gIC8vIHJlbmRlclxuICB0aGlzLmRyYXcoZywgc2NlbmUsIGIpO1xuICBcbiAgLy8gdGFrZWRvd25cbiAgZy5yZXN0b3JlKCk7XG4gIHRoaXMuX3NjZW5lID0gbnVsbDsgLy8gY2xlYXIgc2NlbmUgY2FjaGVcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24oY3R4LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZhciBtYXJrID0gbWFya3Nbc2NlbmUubWFya3R5cGVdO1xuICBtYXJrLmRyYXcuY2FsbCh0aGlzLCBjdHgsIHNjZW5lLCBib3VuZHMpO1xufTtcblxucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuICB2YXIgZyA9IHRoaXMuY29udGV4dCgpO1xuICBnLmNsZWFyUmVjdCh4LCB5LCB3LCBoKTtcbiAgaWYgKHRoaXMuX2JnY29sb3IgIT0gbnVsbCkge1xuICAgIGcuZmlsbFN0eWxlID0gdGhpcy5fYmdjb2xvcjtcbiAgICBnLmZpbGxSZWN0KHgsIHksIHcsIGgpOyBcbiAgfVxufTtcblxucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKHVyaSkge1xuICB2YXIgcmVuZGVyZXIgPSB0aGlzLFxuICAgICAgc2NlbmUgPSB0aGlzLl9zY2VuZTtcbiAgcmV0dXJuIHRoaXMuX2xvYWRlci5sb2FkSW1hZ2UodXJpLCBmdW5jdGlvbigpIHtcbiAgICByZW5kZXJlci5yZW5kZXJBc3luYyhzY2VuZSk7XG4gIH0pO1xufTtcblxucHJvdG90eXBlLnJlbmRlckFzeW5jID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgLy8gVE9ETyBtYWtlIHNhZmUgZm9yIG11bHRpcGxlIHNjZW5lIHJlbmRlcmluZz9cbiAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgaWYgKHJlbmRlcmVyLl9hc3luY19pZCkge1xuICAgIGNsZWFyVGltZW91dChyZW5kZXJlci5fYXN5bmNfaWQpO1xuICB9XG4gIHJlbmRlcmVyLl9hc3luY19pZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lKTtcbiAgICBkZWxldGUgcmVuZGVyZXIuX2FzeW5jX2lkO1xuICB9LCAxMCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhc1JlbmRlcmVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEhhbmRsZXI6ICByZXF1aXJlKCcuL0NhbnZhc0hhbmRsZXInKSxcbiAgUmVuZGVyZXI6IHJlcXVpcmUoJy4vQ2FudmFzUmVuZGVyZXInKVxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGhhbGZwaSA9IE1hdGguUEkgLyAyO1xuXG5mdW5jdGlvbiBwYXRoKGcsIG8pIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIGlyID0gby5pbm5lclJhZGl1cyB8fCAwLFxuICAgICAgb3IgPSBvLm91dGVyUmFkaXVzIHx8IDAsXG4gICAgICBzYSA9IChvLnN0YXJ0QW5nbGUgfHwgMCkgLSBoYWxmcGksXG4gICAgICBlYSA9IChvLmVuZEFuZ2xlIHx8IDApIC0gaGFsZnBpO1xuICBnLmJlZ2luUGF0aCgpO1xuICBpZiAoaXIgPT09IDApIGcubW92ZVRvKHgsIHkpO1xuICBlbHNlIGcuYXJjKHgsIHksIGlyLCBzYSwgZWEsIDApO1xuICBnLmFyYyh4LCB5LCBvciwgZWEsIHNhLCAxKTtcbiAgZy5jbG9zZVBhdGgoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRyYXc6IHV0aWwuZHJhd0FsbChwYXRoKSxcbiAgcGljazogdXRpbC5waWNrUGF0aChwYXRoKVxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpLFxuICAgIHBhcnNlID0gcmVxdWlyZSgnLi4vLi4vLi4vcGF0aC9wYXJzZScpLFxuICAgIHJlbmRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL3BhdGgvcmVuZGVyJyksXG4gICAgYXJlYVBhdGggPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL3N2ZycpLnBhdGguYXJlYTtcblxuZnVuY3Rpb24gcGF0aChnLCBpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgcCA9IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlKGFyZWFQYXRoKGl0ZW1zKSkpO1xuICByZW5kZXIoZywgcCk7XG59XG5cbmZ1bmN0aW9uIHBpY2soZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIGIgPSBzY2VuZS5ib3VuZHM7XG5cbiAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoIHx8IGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGcucGl4ZWxyYXRpbyAhPSBudWxsICYmIGcucGl4ZWxyYXRpbyAhPT0gMSkge1xuICAgIHggKj0gZy5waXhlbHJhdGlvO1xuICAgIHkgKj0gZy5waXhlbHJhdGlvO1xuICB9XG4gIHJldHVybiBoaXQoZywgaXRlbXMsIHgsIHkpID8gaXRlbXNbMF0gOiBudWxsO1xufVxuXG52YXIgaGl0ID0gdXRpbC50ZXN0UGF0aChwYXRoKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRyYXc6IHV0aWwuZHJhd09uZShwYXRoKSxcbiAgcGljazogcGljayxcbiAgbmVzdGVkOiB0cnVlXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBFTVBUWSA9IFtdO1xuXG5mdW5jdGlvbiBkcmF3KGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcyB8fCAhc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG5cbiAgdmFyIGdyb3VwcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgcmVuZGVyZXIgPSB0aGlzLFxuICAgICAgZ3JvdXAsIGl0ZW1zLCBheGVzLCBsZWdlbmRzLCBneCwgZ3ksIHcsIGgsIG9wYWMsIGksIG4sIGosIG07XG5cbiAgZm9yIChpPTAsIG49Z3JvdXBzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBncm91cCA9IGdyb3Vwc1tpXTtcbiAgICBheGVzID0gZ3JvdXAuYXhpc0l0ZW1zIHx8IEVNUFRZO1xuICAgIGl0ZW1zID0gZ3JvdXAuaXRlbXMgfHwgRU1QVFk7XG4gICAgbGVnZW5kcyA9IGdyb3VwLmxlZ2VuZEl0ZW1zIHx8IEVNUFRZO1xuICAgIGd4ID0gZ3JvdXAueCB8fCAwO1xuICAgIGd5ID0gZ3JvdXAueSB8fCAwO1xuICAgIHcgPSBncm91cC53aWR0aCB8fCAwO1xuICAgIGggPSBncm91cC5oZWlnaHQgfHwgMDtcblxuICAgIC8vIGRyYXcgZ3JvdXAgYmFja2dyb3VuZFxuICAgIGlmIChncm91cC5zdHJva2UgfHwgZ3JvdXAuZmlsbCkge1xuICAgICAgb3BhYyA9IGdyb3VwLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBncm91cC5vcGFjaXR5O1xuICAgICAgaWYgKG9wYWMgPiAwKSB7XG4gICAgICAgIGlmIChncm91cC5maWxsICYmIHV0aWwuZmlsbChnLCBncm91cCwgb3BhYykpIHtcbiAgICAgICAgICBnLmZpbGxSZWN0KGd4LCBneSwgdywgaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyb3VwLnN0cm9rZSAmJiB1dGlsLnN0cm9rZShnLCBncm91cCwgb3BhYykpIHtcbiAgICAgICAgICBnLnN0cm9rZVJlY3QoZ3gsIGd5LCB3LCBoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNldHVwIGdyYXBoaWNzIGNvbnRleHRcbiAgICBnLnNhdmUoKTtcbiAgICBnLnRyYW5zbGF0ZShneCwgZ3kpO1xuICAgIGlmIChncm91cC5jbGlwKSB7XG4gICAgICBnLmJlZ2luUGF0aCgpO1xuICAgICAgZy5yZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgZy5jbGlwKCk7XG4gICAgfVxuICAgIGlmIChib3VuZHMpIGJvdW5kcy50cmFuc2xhdGUoLWd4LCAtZ3kpO1xuXG4gICAgLy8gZHJhdyBncm91cCBjb250ZW50c1xuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0ubGF5ZXIgPT09ICdiYWNrJykge1xuICAgICAgICByZW5kZXJlci5kcmF3KGcsIGF4ZXNbal0sIGJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWl0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgIHJlbmRlcmVyLmRyYXcoZywgaXRlbXNbal0sIGJvdW5kcyk7XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgaWYgKGF4ZXNbal0ubGF5ZXIgIT09ICdiYWNrJykge1xuICAgICAgICByZW5kZXJlci5kcmF3KGcsIGF4ZXNbal0sIGJvdW5kcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgICAgcmVuZGVyZXIuZHJhdyhnLCBsZWdlbmRzW2pdLCBib3VuZHMpO1xuICAgIH1cblxuICAgIC8vIHJlc3RvcmUgZ3JhcGhpY3MgY29udGV4dFxuICAgIGlmIChib3VuZHMpIGJvdW5kcy50cmFuc2xhdGUoZ3gsIGd5KTtcbiAgICBnLnJlc3RvcmUoKTtcbiAgfSAgICBcbn1cblxuZnVuY3Rpb24gcGljayhnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KSB7XG4gIGlmIChzY2VuZS5ib3VuZHMgJiYgIXNjZW5lLmJvdW5kcy5jb250YWlucyhneCwgZ3kpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZ3JvdXBzID0gc2NlbmUuaXRlbXMgfHwgRU1QVFksIHN1YnNjZW5lLFxuICAgICAgZ3JvdXAsIGF4ZXMsIGl0ZW1zLCBsZWdlbmRzLCBoaXRzLCBkeCwgZHksIGksIGosIGI7XG5cbiAgZm9yIChpPWdyb3Vwcy5sZW5ndGg7IC0taT49MDspIHtcbiAgICBncm91cCA9IGdyb3Vwc1tpXTtcblxuICAgIC8vIGZpcnN0IGhpdCB0ZXN0IGFnYWluc3QgYm91bmRpbmcgYm94XG4gICAgLy8gaWYgYSBncm91cCBpcyBjbGlwcGVkLCB0aGF0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoZSBib3VuZHMgY2hlY2suXG4gICAgYiA9IGdyb3VwLmJvdW5kcztcbiAgICBpZiAoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpKSBjb250aW51ZTtcblxuICAgIC8vIHBhc3NlZCBib3VuZHMgY2hlY2ssIHNvIHRlc3Qgc3ViLWdyb3Vwc1xuICAgIGF4ZXMgPSBncm91cC5heGlzSXRlbXMgfHwgRU1QVFk7XG4gICAgaXRlbXMgPSBncm91cC5pdGVtcyB8fCBFTVBUWTtcbiAgICBsZWdlbmRzID0gZ3JvdXAubGVnZW5kSXRlbXMgfHwgRU1QVFk7XG4gICAgZHggPSAoZ3JvdXAueCB8fCAwKTtcbiAgICBkeSA9IChncm91cC55IHx8IDApO1xuXG4gICAgZy5zYXZlKCk7XG4gICAgZy50cmFuc2xhdGUoZHgsIGR5KTtcbiAgICBkeCA9IGd4IC0gZHg7XG4gICAgZHkgPSBneSAtIGR5O1xuICAgIGZvciAoaj1sZWdlbmRzLmxlbmd0aDsgLS1qPj0wOykge1xuICAgICAgc3Vic2NlbmUgPSBsZWdlbmRzW2pdO1xuICAgICAgaWYgKHN1YnNjZW5lLmludGVyYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICBoaXRzID0gdGhpcy5waWNrKHN1YnNjZW5lLCB4LCB5LCBkeCwgZHkpO1xuICAgICAgICBpZiAoaGl0cykgeyBnLnJlc3RvcmUoKTsgcmV0dXJuIGhpdHM7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChqPWF4ZXMubGVuZ3RoOyAtLWo+PTA7KSB7XG4gICAgICBzdWJzY2VuZSA9IGF4ZXNbal07XG4gICAgICBpZiAoc3Vic2NlbmUuaW50ZXJhY3RpdmUgIT09IGZhbHNlICYmIHN1YnNjZW5lLmxheWVyICE9PSAnYmFjaycpIHtcbiAgICAgICAgaGl0cyA9IHRoaXMucGljayhzdWJzY2VuZSwgeCwgeSwgZHgsIGR5KTtcbiAgICAgICAgaWYgKGhpdHMpIHsgZy5yZXN0b3JlKCk7IHJldHVybiBoaXRzOyB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaj1pdGVtcy5sZW5ndGg7IC0taj49MDspIHtcbiAgICAgIHN1YnNjZW5lID0gaXRlbXNbal07XG4gICAgICBpZiAoc3Vic2NlbmUuaW50ZXJhY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgIGhpdHMgPSB0aGlzLnBpY2soc3Vic2NlbmUsIHgsIHksIGR4LCBkeSk7XG4gICAgICAgIGlmIChoaXRzKSB7IGcucmVzdG9yZSgpOyByZXR1cm4gaGl0czsgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGo9YXhlcy5sZW5ndGg7IC0taj49MDspIHtcbiAgICAgIHN1YnNjZW5lID0gYXhlc1tqXTtcbiAgICAgIGlmIChzdWJzY2VuZS5pbnRlcmF0aXZlICE9PSBmYWxzZSAmJiBzdWJzY2VuZS5sYXllciA9PT0gJ2JhY2snKSB7XG4gICAgICAgIGhpdHMgPSB0aGlzLnBpY2soc3Vic2NlbmUsIHgsIHksIGR4LCBkeSk7XG4gICAgICAgIGlmIChoaXRzKSB7IGcucmVzdG9yZSgpOyByZXR1cm4gaGl0czsgfVxuICAgICAgfVxuICAgIH1cbiAgICBnLnJlc3RvcmUoKTtcblxuICAgIGlmIChzY2VuZS5pbnRlcmFjdGl2ZSAhPT0gZmFsc2UgJiYgKGdyb3VwLmZpbGwgfHwgZ3JvdXAuc3Ryb2tlKSAmJlxuICAgICAgICBkeCA+PSAwICYmIGR4IDw9IGdyb3VwLndpZHRoICYmIGR5ID49IDAgJiYgZHkgPD0gZ3JvdXAuaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiBkcmF3LFxuICBwaWNrOiBwaWNrXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZnVuY3Rpb24gZHJhdyhnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMgfHwgIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHZhciByZW5kZXJlciA9IHRoaXMsXG4gICAgICBpdGVtcyA9IHNjZW5lLml0ZW1zLCBvO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBpZiAoIShvLmltYWdlICYmIG8uaW1hZ2UudXJsID09PSBvLnVybCkpIHtcbiAgICAgIG8uaW1hZ2UgPSByZW5kZXJlci5sb2FkSW1hZ2Uoby51cmwpO1xuICAgICAgby5pbWFnZS51cmwgPSBvLnVybDtcbiAgICB9XG5cbiAgICB2YXIgeCA9IG8ueCB8fCAwLFxuICAgICAgICB5ID0gby55IHx8IDAsXG4gICAgICAgIHcgPSBvLndpZHRoIHx8IChvLmltYWdlICYmIG8uaW1hZ2Uud2lkdGgpIHx8IDAsXG4gICAgICAgIGggPSBvLmhlaWdodCB8fCAoby5pbWFnZSAmJiBvLmltYWdlLmhlaWdodCkgfHwgMCxcbiAgICAgICAgb3BhYztcbiAgICB4ID0geCAtIChvLmFsaWduPT09J2NlbnRlcicgPyB3LzIgOiBvLmFsaWduPT09J3JpZ2h0JyA/IHcgOiAwKTtcbiAgICB5ID0geSAtIChvLmJhc2VsaW5lPT09J21pZGRsZScgPyBoLzIgOiBvLmJhc2VsaW5lPT09J2JvdHRvbScgPyBoIDogMCk7XG5cbiAgICBpZiAoby5pbWFnZS5sb2FkZWQpIHtcbiAgICAgIGcuZ2xvYmFsQWxwaGEgPSAob3BhYyA9IG8ub3BhY2l0eSkgIT0gbnVsbCA/IG9wYWMgOiAxO1xuICAgICAgZy5kcmF3SW1hZ2Uoby5pbWFnZSwgeCwgeSwgdywgaCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiBkcmF3LFxuICBwaWNrOiB1dGlsLnBpY2soKVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJjOiAgICByZXF1aXJlKCcuL2FyYycpLFxuICBhcmVhOiAgIHJlcXVpcmUoJy4vYXJlYScpLFxuICBncm91cDogIHJlcXVpcmUoJy4vZ3JvdXAnKSxcbiAgaW1hZ2U6ICByZXF1aXJlKCcuL2ltYWdlJyksXG4gIGxpbmU6ICAgcmVxdWlyZSgnLi9saW5lJyksXG4gIHBhdGg6ICAgcmVxdWlyZSgnLi9wYXRoJyksXG4gIHJlY3Q6ICAgcmVxdWlyZSgnLi9yZWN0JyksXG4gIHJ1bGU6ICAgcmVxdWlyZSgnLi9ydWxlJyksXG4gIHN5bWJvbDogcmVxdWlyZSgnLi9zeW1ib2wnKSxcbiAgdGV4dDogICByZXF1aXJlKCcuL3RleHQnKVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgcGFyc2UgPSByZXF1aXJlKCcuLi8uLi8uLi9wYXRoL3BhcnNlJyksXG4gICAgcmVuZGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vcGF0aC9yZW5kZXInKSxcbiAgICBsaW5lUGF0aCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvc3ZnJykucGF0aC5saW5lO1xuICAgIFxuZnVuY3Rpb24gcGF0aChnLCBpdGVtcykge1xuICB2YXIgbyA9IGl0ZW1zWzBdLFxuICAgICAgcCA9IG8ucGF0aENhY2hlIHx8IChvLnBhdGhDYWNoZSA9IHBhcnNlKGxpbmVQYXRoKGl0ZW1zKSkpO1xuICByZW5kZXIoZywgcCk7XG59XG5cbmZ1bmN0aW9uIHBpY2soZywgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIGIgPSBzY2VuZS5ib3VuZHM7XG5cbiAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoIHx8IGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGcucGl4ZWxyYXRpbyAhPSBudWxsICYmIGcucGl4ZWxyYXRpbyAhPT0gMSkge1xuICAgIHggKj0gZy5waXhlbHJhdGlvO1xuICAgIHkgKj0gZy5waXhlbHJhdGlvO1xuICB9XG4gIHJldHVybiBoaXQoZywgaXRlbXMsIHgsIHkpID8gaXRlbXNbMF0gOiBudWxsO1xufVxuXG52YXIgaGl0ID0gdXRpbC50ZXN0UGF0aChwYXRoLCBmYWxzZSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiB1dGlsLmRyYXdPbmUocGF0aCksXG4gIHBpY2s6IHBpY2ssXG4gIG5lc3RlZDogdHJ1ZVxufTtcbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgcGFyc2UgPSByZXF1aXJlKCcuLi8uLi8uLi9wYXRoL3BhcnNlJyksXG4gICAgcmVuZGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vcGF0aC9yZW5kZXInKTtcblxuZnVuY3Rpb24gcGF0aChnLCBvKSB7XG4gIGlmIChvLnBhdGggPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHZhciBwID0gby5wYXRoQ2FjaGUgfHwgKG8ucGF0aENhY2hlID0gcGFyc2Uoby5wYXRoKSk7XG4gIHJlbmRlcihnLCBwLCBvLngsIG8ueSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiB1dGlsLmRyYXdBbGwocGF0aCksXG4gIHBpY2s6IHV0aWwucGlja1BhdGgocGF0aClcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5mdW5jdGlvbiBkcmF3KGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgaWYgKCFzY2VuZS5pdGVtcyB8fCAhc2NlbmUuaXRlbXMubGVuZ3RoKSByZXR1cm47XG5cbiAgdmFyIGl0ZW1zID0gc2NlbmUuaXRlbXMsXG4gICAgICBvLCBvcGFjLCB4LCB5LCB3LCBoO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICAgIGlmIChvcGFjID09PSAwKSBjb250aW51ZTtcblxuICAgIHggPSBvLnggfHwgMDtcbiAgICB5ID0gby55IHx8IDA7XG4gICAgdyA9IG8ud2lkdGggfHwgMDtcbiAgICBoID0gby5oZWlnaHQgfHwgMDtcblxuICAgIGlmIChvLmZpbGwgJiYgdXRpbC5maWxsKGcsIG8sIG9wYWMpKSB7XG4gICAgICBnLmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIH1cbiAgICBpZiAoby5zdHJva2UgJiYgdXRpbC5zdHJva2UoZywgbywgb3BhYykpIHtcbiAgICAgIGcuc3Ryb2tlUmVjdCh4LCB5LCB3LCBoKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRyYXc6IGRyYXcsXG4gIHBpY2s6IHV0aWwucGljaygpXG59OyIsInZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmZ1bmN0aW9uIGRyYXcoZywgc2NlbmUsIGJvdW5kcykge1xuICBpZiAoIXNjZW5lLml0ZW1zIHx8ICFzY2VuZS5pdGVtcy5sZW5ndGgpIHJldHVybjtcblxuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIG8sIG9wYWMsIHgxLCB5MSwgeDIsIHkyO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBvcGFjID0gby5vcGFjaXR5ID09IG51bGwgPyAxIDogby5vcGFjaXR5O1xuICAgIGlmIChvcGFjID09PSAwKSBjb250aW51ZTtcbiAgICAgIFxuICAgIHgxID0gby54IHx8IDA7XG4gICAgeTEgPSBvLnkgfHwgMDtcbiAgICB4MiA9IG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MTtcbiAgICB5MiA9IG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MTtcblxuICAgIGlmIChvLnN0cm9rZSAmJiB1dGlsLnN0cm9rZShnLCBvLCBvcGFjKSkge1xuICAgICAgZy5iZWdpblBhdGgoKTtcbiAgICAgIGcubW92ZVRvKHgxLCB5MSk7XG4gICAgICBnLmxpbmVUbyh4MiwgeTIpO1xuICAgICAgZy5zdHJva2UoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3Ryb2tlKGcsIG8pIHtcbiAgdmFyIHgxID0gby54IHx8IDAsXG4gICAgICB5MSA9IG8ueSB8fCAwLFxuICAgICAgeDIgPSBvLngyICE9IG51bGwgPyBvLngyIDogeDEsXG4gICAgICB5MiA9IG8ueTIgIT0gbnVsbCA/IG8ueTIgOiB5MSxcbiAgICAgIGx3ID0gby5zdHJva2VXaWR0aCxcbiAgICAgIGxjID0gby5zdHJva2VDYXA7XG5cbiAgZy5saW5lV2lkdGggPSBsdyAhPSBudWxsID8gbHcgOiAxO1xuICBnLmxpbmVDYXAgICA9IGxjICE9IG51bGwgPyBsYyA6ICdidXR0JztcbiAgZy5iZWdpblBhdGgoKTtcbiAgZy5tb3ZlVG8oeDEsIHkxKTtcbiAgZy5saW5lVG8oeDIsIHkyKTtcbn1cblxuZnVuY3Rpb24gaGl0KGcsIG8sIHgsIHkpIHtcbiAgaWYgKCFnLmlzUG9pbnRJblN0cm9rZSkgcmV0dXJuIGZhbHNlO1xuICBzdHJva2UoZywgbyk7XG4gIHJldHVybiBnLmlzUG9pbnRJblN0cm9rZSh4LCB5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRyYXc6IGRyYXcsXG4gIHBpY2s6IHV0aWwucGljayhoaXQpXG59O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmFyIHNxcnQzID0gTWF0aC5zcXJ0KDMpLFxuICAgIHRhbjMwID0gTWF0aC50YW4oMzAgKiBNYXRoLlBJIC8gMTgwKTtcblxuZnVuY3Rpb24gcGF0aChnLCBvKSB7XG4gIHZhciBzaXplID0gby5zaXplICE9IG51bGwgPyBvLnNpemUgOiAxMDAsXG4gICAgICB4ID0gby54LCB5ID0gby55LCByLCB0LCByeCwgcnk7XG5cbiAgZy5iZWdpblBhdGgoKTtcblxuICBpZiAoby5zaGFwZSA9PSBudWxsIHx8IG8uc2hhcGUgPT09ICdjaXJjbGUnKSB7XG4gICAgciA9IE1hdGguc3FydChzaXplIC8gTWF0aC5QSSk7XG4gICAgZy5hcmMoeCwgeSwgciwgMCwgMipNYXRoLlBJLCAwKTtcbiAgICBnLmNsb3NlUGF0aCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoby5zaGFwZSkge1xuICAgIGNhc2UgJ2Nyb3NzJzpcbiAgICAgIHIgPSBNYXRoLnNxcnQoc2l6ZSAvIDUpIC8gMjtcbiAgICAgIHQgPSAzKnI7XG4gICAgICBnLm1vdmVUbyh4LXQsIHktcik7XG4gICAgICBnLmxpbmVUbyh4LXIsIHktcik7XG4gICAgICBnLmxpbmVUbyh4LXIsIHktdCk7XG4gICAgICBnLmxpbmVUbyh4K3IsIHktdCk7XG4gICAgICBnLmxpbmVUbyh4K3IsIHktcik7XG4gICAgICBnLmxpbmVUbyh4K3QsIHktcik7XG4gICAgICBnLmxpbmVUbyh4K3QsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4K3IsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4K3IsIHkrdCk7XG4gICAgICBnLmxpbmVUbyh4LXIsIHkrdCk7XG4gICAgICBnLmxpbmVUbyh4LXIsIHkrcik7XG4gICAgICBnLmxpbmVUbyh4LXQsIHkrcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RpYW1vbmQnOlxuICAgICAgcnkgPSBNYXRoLnNxcnQoc2l6ZSAvICgyICogdGFuMzApKTtcbiAgICAgIHJ4ID0gcnkgKiB0YW4zMDtcbiAgICAgIGcubW92ZVRvKHgsIHktcnkpO1xuICAgICAgZy5saW5lVG8oeCtyeCwgeSk7XG4gICAgICBnLmxpbmVUbyh4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgtcngsIHkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdzcXVhcmUnOlxuICAgICAgdCA9IE1hdGguc3FydChzaXplKTtcbiAgICAgIHIgPSB0IC8gMjtcbiAgICAgIGcucmVjdCh4LXIsIHktciwgdCwgdCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RyaWFuZ2xlLWRvd24nOlxuICAgICAgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIHNxcnQzKTtcbiAgICAgIHJ5ID0gcnggKiBzcXJ0MyAvIDI7XG4gICAgICBnLm1vdmVUbyh4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgrcngsIHktcnkpO1xuICAgICAgZy5saW5lVG8oeC1yeCwgeS1yeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3RyaWFuZ2xlLXVwJzpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgZy5tb3ZlVG8oeCwgeS1yeSk7XG4gICAgICBnLmxpbmVUbyh4K3J4LCB5K3J5KTtcbiAgICAgIGcubGluZVRvKHgtcngsIHkrcnkpO1xuICB9XG4gIGcuY2xvc2VQYXRoKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3OiB1dGlsLmRyYXdBbGwocGF0aCksXG4gIHBpY2s6IHV0aWwucGlja1BhdGgocGF0aClcbn07IiwidmFyIEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvQm91bmRzJyksXG4gICAgdGV4dEJvdW5kcyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvYm91bmQnKS50ZXh0LFxuICAgIHRleHQgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL3RleHQnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgdGVtcEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcblxuZnVuY3Rpb24gZHJhdyhnLCBzY2VuZSwgYm91bmRzKSB7XG4gIGlmICghc2NlbmUuaXRlbXMgfHwgIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgICAgbywgb3BhYywgeCwgeSwgciwgdCwgc3RyO1xuXG4gIGZvciAodmFyIGk9MCwgbGVuPWl0ZW1zLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIG8gPSBpdGVtc1tpXTtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhvLmJvdW5kcykpXG4gICAgICBjb250aW51ZTsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBzdHIgPSB0ZXh0LnZhbHVlKG8udGV4dCk7XG4gICAgaWYgKCFzdHIpIGNvbnRpbnVlO1xuICAgIG9wYWMgPSBvLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBvLm9wYWNpdHk7XG4gICAgaWYgKG9wYWMgPT09IDApIGNvbnRpbnVlO1xuXG4gICAgZy5mb250ID0gdGV4dC5mb250KG8pO1xuICAgIGcudGV4dEFsaWduID0gby5hbGlnbiB8fCAnbGVmdCc7XG5cbiAgICB4ID0gKG8ueCB8fCAwKTtcbiAgICB5ID0gKG8ueSB8fCAwKTtcbiAgICBpZiAoKHIgPSBvLnJhZGl1cykpIHtcbiAgICAgIHQgPSAoby50aGV0YSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gICAgfVxuXG4gICAgaWYgKG8uYW5nbGUpIHtcbiAgICAgIGcuc2F2ZSgpO1xuICAgICAgZy50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBnLnJvdGF0ZShvLmFuZ2xlICogTWF0aC5QSS8xODApO1xuICAgICAgeCA9IHkgPSAwOyAvLyByZXNldCB4LCB5XG4gICAgfVxuICAgIHggKz0gKG8uZHggfHwgMCk7XG4gICAgeSArPSAoby5keSB8fCAwKSArIHRleHQub2Zmc2V0KG8pO1xuXG4gICAgaWYgKG8uZmlsbCAmJiB1dGlsLmZpbGwoZywgbywgb3BhYykpIHtcbiAgICAgIGcuZmlsbFRleHQoc3RyLCB4LCB5KTtcbiAgICB9XG4gICAgaWYgKG8uc3Ryb2tlICYmIHV0aWwuc3Ryb2tlKGcsIG8sIG9wYWMpKSB7XG4gICAgICBnLnN0cm9rZVRleHQoc3RyLCB4LCB5KTtcbiAgICB9XG4gICAgaWYgKG8uYW5nbGUpIGcucmVzdG9yZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhpdChnLCBvLCB4LCB5LCBneCwgZ3kpIHtcbiAgaWYgKG8uZm9udFNpemUgPD0gMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoIW8uYW5nbGUpIHJldHVybiB0cnVlOyAvLyBib3VuZHMgc3VmZmljaWVudCBpZiBubyByb3RhdGlvblxuXG4gIC8vIHByb2plY3QgcG9pbnQgaW50byBzcGFjZSBvZiB1bnJvdGF0ZWQgYm91bmRzXG4gIHZhciBiID0gdGV4dEJvdW5kcyhvLCB0ZW1wQm91bmRzLCB0cnVlKSxcbiAgICAgIGEgPSAtby5hbmdsZSAqIE1hdGguUEkgLyAxODAsXG4gICAgICBjb3MgPSBNYXRoLmNvcyhhKSxcbiAgICAgIHNpbiA9IE1hdGguc2luKGEpLFxuICAgICAgb3ggPSBvLngsXG4gICAgICBveSA9IG8ueSxcbiAgICAgIHB4ID0gY29zKmd4IC0gc2luKmd5ICsgKG94IC0gb3gqY29zICsgb3kqc2luKSxcbiAgICAgIHB5ID0gc2luKmd4ICsgY29zKmd5ICsgKG95IC0gb3gqc2luIC0gb3kqY29zKTtcblxuICByZXR1cm4gYi5jb250YWlucyhweCwgcHkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZHJhdzogZHJhdyxcbiAgcGljazogdXRpbC5waWNrKGhpdClcbn07XG4iLCJmdW5jdGlvbiBkcmF3UGF0aE9uZShwYXRoLCBnLCBvLCBpdGVtcykge1xuICBpZiAocGF0aChnLCBpdGVtcykpIHJldHVybjtcblxuICB2YXIgb3BhYyA9IG8ub3BhY2l0eSA9PSBudWxsID8gMSA6IG8ub3BhY2l0eTtcbiAgaWYgKG9wYWM9PT0wKSByZXR1cm47XG5cbiAgaWYgKG8uZmlsbCAmJiBmaWxsKGcsIG8sIG9wYWMpKSB7IGcuZmlsbCgpOyB9XG4gIGlmIChvLnN0cm9rZSAmJiBzdHJva2UoZywgbywgb3BhYykpIHsgZy5zdHJva2UoKTsgfVxufVxuXG5mdW5jdGlvbiBkcmF3UGF0aEFsbChwYXRoLCBnLCBzY2VuZSwgYm91bmRzKSB7XG4gIHZhciBpLCBsZW4sIGl0ZW07XG4gIGZvciAoaT0wLCBsZW49c2NlbmUuaXRlbXMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgaXRlbSA9IHNjZW5lLml0ZW1zW2ldO1xuICAgIGlmICghYm91bmRzIHx8IGJvdW5kcy5pbnRlcnNlY3RzKGl0ZW0uYm91bmRzKSkge1xuICAgICAgZHJhd1BhdGhPbmUocGF0aCwgZywgaXRlbSwgaXRlbSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdBbGwocGF0aEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgICBkcmF3UGF0aEFsbChwYXRoRnVuYywgZywgc2NlbmUsIGJvdW5kcyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGRyYXdPbmUocGF0aEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCBib3VuZHMpIHtcbiAgICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICAgIGlmICghYm91bmRzIHx8IGJvdW5kcy5pbnRlcnNlY3RzKHNjZW5lLmJvdW5kcykpIHtcbiAgICAgIGRyYXdQYXRoT25lKHBhdGhGdW5jLCBnLCBzY2VuZS5pdGVtc1swXSwgc2NlbmUuaXRlbXMpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHRydWVGdW5jID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuXG5mdW5jdGlvbiBwaWNrKHRlc3QpIHtcbiAgaWYgKCF0ZXN0KSB0ZXN0ID0gdHJ1ZUZ1bmM7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGcsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgICBpZiAoIXNjZW5lLml0ZW1zLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgbywgYiwgaTtcblxuICAgIGlmIChnLnBpeGVscmF0aW8gIT0gbnVsbCAmJiBnLnBpeGVscmF0aW8gIT09IDEpIHtcbiAgICAgIHggKj0gZy5waXhlbHJhdGlvO1xuICAgICAgeSAqPSBnLnBpeGVscmF0aW87XG4gICAgfVxuXG4gICAgZm9yIChpPXNjZW5lLml0ZW1zLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICBvID0gc2NlbmUuaXRlbXNbaV07IGIgPSBvLmJvdW5kcztcbiAgICAgIC8vIGZpcnN0IGhpdCB0ZXN0IGFnYWluc3QgYm91bmRpbmcgYm94XG4gICAgICBpZiAoKGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkgfHwgIWIpIGNvbnRpbnVlO1xuICAgICAgLy8gaWYgaW4gYm91bmRpbmcgYm94LCBwZXJmb3JtIG1vcmUgY2FyZWZ1bCB0ZXN0XG4gICAgICBpZiAodGVzdChnLCBvLCB4LCB5LCBneCwgZ3kpKSByZXR1cm4gbztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRlc3RQYXRoKHBhdGgsIGZpbGxlZCkge1xuICByZXR1cm4gZnVuY3Rpb24oZywgbywgeCwgeSkge1xuICAgIHZhciBpdGVtID0gQXJyYXkuaXNBcnJheShvKSA/IG9bMF0gOiBvLFxuICAgICAgICBmaWxsID0gKGZpbGxlZCA9PSBudWxsKSA/IGl0ZW0uZmlsbCA6IGZpbGxlZCxcbiAgICAgICAgc3Ryb2tlID0gaXRlbS5zdHJva2UgJiYgZy5pc1BvaW50SW5TdHJva2UsIGx3LCBsYztcblxuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGx3ID0gaXRlbS5zdHJva2VXaWR0aDtcbiAgICAgIGxjID0gaXRlbS5zdHJva2VDYXA7XG4gICAgICBnLmxpbmVXaWR0aCA9IGx3ICE9IG51bGwgPyBsdyA6IDE7XG4gICAgICBnLmxpbmVDYXAgICA9IGxjICE9IG51bGwgPyBsYyA6ICdidXR0JztcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aChnLCBvKSA/IGZhbHNlIDpcbiAgICAgIChmaWxsICYmIGcuaXNQb2ludEluUGF0aCh4LCB5KSkgfHxcbiAgICAgIChzdHJva2UgJiYgZy5pc1BvaW50SW5TdHJva2UoeCwgeSkpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwaWNrUGF0aChwYXRoKSB7XG4gIHJldHVybiBwaWNrKHRlc3RQYXRoKHBhdGgpKTtcbn1cblxuZnVuY3Rpb24gZmlsbChnLCBvLCBvcGFjaXR5KSB7XG4gIG9wYWNpdHkgKj0gKG8uZmlsbE9wYWNpdHk9PW51bGwgPyAxIDogby5maWxsT3BhY2l0eSk7XG4gIGlmIChvcGFjaXR5ID4gMCkge1xuICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgIGcuZmlsbFN0eWxlID0gY29sb3IoZywgbywgby5maWxsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3Ryb2tlKGcsIG8sIG9wYWNpdHkpIHtcbiAgdmFyIGx3ID0gKGx3ID0gby5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogMSwgbGM7XG4gIGlmIChsdyA8PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgb3BhY2l0eSAqPSAoby5zdHJva2VPcGFjaXR5PT1udWxsID8gMSA6IG8uc3Ryb2tlT3BhY2l0eSk7XG4gIGlmIChvcGFjaXR5ID4gMCkge1xuICAgIGcuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgIGcuc3Ryb2tlU3R5bGUgPSBjb2xvcihnLCBvLCBvLnN0cm9rZSk7XG4gICAgZy5saW5lV2lkdGggPSBsdztcbiAgICBnLmxpbmVDYXAgPSAobGMgPSBvLnN0cm9rZUNhcCkgIT0gbnVsbCA/IGxjIDogJ2J1dHQnO1xuICAgIGcudmdMaW5lRGFzaChvLnN0cm9rZURhc2ggfHwgbnVsbCk7XG4gICAgZy52Z0xpbmVEYXNoT2Zmc2V0KG8uc3Ryb2tlRGFzaE9mZnNldCB8fCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29sb3IoZywgbywgdmFsdWUpIHtcbiAgcmV0dXJuICh2YWx1ZS5pZCkgP1xuICAgIGdyYWRpZW50KGcsIHZhbHVlLCBvLmJvdW5kcykgOlxuICAgIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBncmFkaWVudChnLCBwLCBiKSB7XG4gIHZhciB3ID0gYi53aWR0aCgpLFxuICAgICAgaCA9IGIuaGVpZ2h0KCksXG4gICAgICB4MSA9IGIueDEgKyBwLngxICogdyxcbiAgICAgIHkxID0gYi55MSArIHAueTEgKiBoLFxuICAgICAgeDIgPSBiLngxICsgcC54MiAqIHcsXG4gICAgICB5MiA9IGIueTEgKyBwLnkyICogaCxcbiAgICAgIGdyYWQgPSBnLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKSxcbiAgICAgIHN0b3AgPSBwLnN0b3BzLFxuICAgICAgaSwgbjtcblxuICBmb3IgKGk9MCwgbj1zdG9wLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBncmFkLmFkZENvbG9yU3RvcChzdG9wW2ldLm9mZnNldCwgc3RvcFtpXS5jb2xvcik7XG4gIH1cbiAgcmV0dXJuIGdyYWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkcmF3T25lOiAgZHJhd09uZSxcbiAgZHJhd0FsbDogIGRyYXdBbGwsXG4gIHBpY2s6ICAgICBwaWNrLFxuICBwaWNrUGF0aDogcGlja1BhdGgsXG4gIHRlc3RQYXRoOiB0ZXN0UGF0aCxcbiAgc3Ryb2tlOiAgIHN0cm9rZSxcbiAgZmlsbDogICAgIGZpbGwsXG4gIGNvbG9yOiAgICBjb2xvcixcbiAgZ3JhZGllbnQ6IGdyYWRpZW50XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICdjYW52YXMnOiByZXF1aXJlKCcuL2NhbnZhcycpLFxuICAnc3ZnJzogICAgcmVxdWlyZSgnLi9zdmcnKVxufTtcbiIsInZhciBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIEhhbmRsZXIgPSByZXF1aXJlKCcuLi9IYW5kbGVyJyk7XG5cbmZ1bmN0aW9uIFNWR0hhbmRsZXIoKSB7XG4gIEhhbmRsZXIuY2FsbCh0aGlzKTtcbn1cblxudmFyIGJhc2UgPSBIYW5kbGVyLnByb3RvdHlwZTtcbnZhciBwcm90b3R5cGUgPSAoU1ZHSGFuZGxlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWR0hhbmRsZXI7XG5cbnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24oZWwsIHBhZCwgb2JqKSB7XG4gIHRoaXMuX3N2ZyA9IERPTS5maW5kKGVsLCAnc3ZnJyk7XG4gIHJldHVybiBiYXNlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBlbCwgcGFkLCBvYmopO1xufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fc3ZnO1xufTtcblxuLy8gd3JhcCBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIFNWRyBET01cbnByb3RvdHlwZS5saXN0ZW5lciA9IGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIHRhcmdldCA9IGV2dC50YXJnZXQsXG4gICAgICAgIGl0ZW0gPSB0YXJnZXQuX19kYXRhX187XG4gICAgZXZ0LnZlZ2FUeXBlID0gZXZ0LnR5cGU7XG4gICAgaXRlbSA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtWzBdIDogaXRlbTtcbiAgICBoYW5kbGVyLmNhbGwodGhhdC5fb2JqLCBldnQsIGl0ZW0pO1xuICB9O1xufTtcblxuLy8gYWRkIGFuIGV2ZW50IGhhbmRsZXJcbnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgdmFyIG5hbWUgPSB0aGlzLmV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIHN2ZyA9IHRoaXMuX3N2ZyxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVycyxcbiAgICAgIHggPSB7XG4gICAgICAgIHR5cGU6ICAgICB0eXBlLFxuICAgICAgICBoYW5kbGVyOiAgaGFuZGxlcixcbiAgICAgICAgbGlzdGVuZXI6IHRoaXMubGlzdGVuZXIoaGFuZGxlcilcbiAgICAgIH07XG5cbiAgKGhbbmFtZV0gfHwgKGhbbmFtZV0gPSBbXSkpLnB1c2goeCk7XG4gIHN2Zy5hZGRFdmVudExpc3RlbmVyKG5hbWUsIHgubGlzdGVuZXIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHJlbW92ZSBhbiBldmVudCBoYW5kbGVyXG5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgaGFuZGxlcikge1xuICB2YXIgbmFtZSA9IHRoaXMuZXZlbnROYW1lKHR5cGUpLFxuICAgICAgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW25hbWVdLCBpO1xuICBpZiAoIWgpIHJldHVybjtcbiAgZm9yIChpPWgubGVuZ3RoOyAtLWk+PTA7KSB7XG4gICAgaWYgKGhbaV0udHlwZSA9PT0gdHlwZSAmJiAhaGFuZGxlciB8fCBoW2ldLmhhbmRsZXIgPT09IGhhbmRsZXIpIHtcbiAgICAgIHN2Zy5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhbaV0ubGlzdGVuZXIpO1xuICAgICAgaC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdIYW5kbGVyO1xuIiwidmFyIEltYWdlTG9hZGVyID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9JbWFnZUxvYWRlcicpLFxuICAgIFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vUmVuZGVyZXInKSxcbiAgICB0ZXh0ID0gcmVxdWlyZSgnLi4vLi4vdXRpbC90ZXh0JyksXG4gICAgRE9NID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9kb20nKSxcbiAgICBTVkcgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N2ZycpLFxuICAgIG5zID0gU1ZHLm1ldGFkYXRhLnhtbG5zLFxuICAgIG1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpO1xuXG5mdW5jdGlvbiBTVkdSZW5kZXJlcihsb2FkQ29uZmlnKSB7XG4gIFJlbmRlcmVyLmNhbGwodGhpcyk7XG4gIHRoaXMuX2xvYWRlciA9IG5ldyBJbWFnZUxvYWRlcihsb2FkQ29uZmlnKTtcbiAgdGhpcy5fZGlydHlJRCA9IDA7XG59XG5cbnZhciBiYXNlID0gUmVuZGVyZXIucHJvdG90eXBlO1xudmFyIHByb3RvdHlwZSA9IChTVkdSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWR1JlbmRlcmVyO1xuXG5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGVsLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIGlmIChlbCkge1xuICAgIHRoaXMuX3N2ZyA9IERPTS5jaGlsZChlbCwgMCwgJ3N2ZycsIG5zLCAnbWFya3MnKTtcbiAgICBET00uY2xlYXIoZWwsIDEpO1xuICAgIC8vIHNldCB0aGUgc3ZnIHJvb3QgZ3JvdXBcbiAgICB0aGlzLl9yb290ID0gRE9NLmNoaWxkKHRoaXMuX3N2ZywgMCwgJ2cnLCBucyk7XG4gICAgRE9NLmNsZWFyKHRoaXMuX3N2ZywgMSk7XG4gIH1cblxuICAvLyBjcmVhdGUgdGhlIHN2ZyBkZWZpbml0aW9ucyBjYWNoZVxuICB0aGlzLl9kZWZzID0ge1xuICAgIGNsaXBfaWQ6ICAxLFxuICAgIGdyYWRpZW50OiB7fSxcbiAgICBjbGlwcGluZzoge31cbiAgfTtcblxuICAvLyBzZXQgYmFja2dyb3VuZCBjb2xvciBpZiBkZWZpbmVkXG4gIHRoaXMuYmFja2dyb3VuZCh0aGlzLl9iZ2NvbG9yKTtcblxuICByZXR1cm4gYmFzZS5pbml0aWFsaXplLmNhbGwodGhpcywgZWwsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xufTtcblxucHJvdG90eXBlLmJhY2tncm91bmQgPSBmdW5jdGlvbihiZ2NvbG9yKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICYmIHRoaXMuX3N2Zykge1xuICAgIHRoaXMuX3N2Zy5zdHlsZS5zZXRQcm9wZXJ0eSgnYmFja2dyb3VuZC1jb2xvcicsIGJnY29sb3IpO1xuICB9XG4gIHJldHVybiBiYXNlLmJhY2tncm91bmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gIGJhc2UucmVzaXplLmNhbGwodGhpcywgd2lkdGgsIGhlaWdodCwgcGFkZGluZyk7XG4gIFxuICBpZiAodGhpcy5fc3ZnKSB7XG4gICAgdmFyIHcgPSB0aGlzLl93aWR0aCxcbiAgICAgICAgaCA9IHRoaXMuX2hlaWdodCxcbiAgICAgICAgcCA9IHRoaXMuX3BhZGRpbmc7XG4gIFxuICAgIHRoaXMuX3N2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdyArIHAubGVmdCArIHAucmlnaHQpO1xuICAgIHRoaXMuX3N2Zy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGggKyBwLnRvcCArIHAuYm90dG9tKTtcbiAgICBcbiAgICB0aGlzLl9yb290LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnK3AubGVmdCsnLCcrcC50b3ArJyknKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX3N2ZykgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGF0dHIgPSB7XG4gICAgJ2NsYXNzJzogICdtYXJrcycsXG4gICAgJ3dpZHRoJzogIHRoaXMuX3dpZHRoICsgdGhpcy5fcGFkZGluZy5sZWZ0ICsgdGhpcy5fcGFkZGluZy5yaWdodCxcbiAgICAnaGVpZ2h0JzogdGhpcy5faGVpZ2h0ICsgdGhpcy5fcGFkZGluZy50b3AgKyB0aGlzLl9wYWRkaW5nLmJvdHRvbSxcbiAgfTtcbiAgZm9yICh2YXIga2V5IGluIFNWRy5tZXRhZGF0YSkge1xuICAgIGF0dHJba2V5XSA9IFNWRy5tZXRhZGF0YVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIERPTS5vcGVuVGFnKCdzdmcnLCBhdHRyKSArIHRoaXMuX3N2Zy5pbm5lckhUTUwgKyBET00uY2xvc2VUYWcoJ3N2ZycpO1xufTtcblxucHJvdG90eXBlLmltYWdlVVJMID0gZnVuY3Rpb24odXJsKSB7XG4gIHJldHVybiB0aGlzLl9sb2FkZXIuaW1hZ2VVUkwodXJsKTtcbn07XG5cblxuLy8gLS0gUmVuZGVyIGVudHJ5IHBvaW50IC0tXG5cbnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihzY2VuZSwgaXRlbXMpIHtcbiAgaWYgKHRoaXMuX2RpcnR5Q2hlY2soaXRlbXMpKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5QWxsKSB0aGlzLl9yZXNldERlZnMoKTtcbiAgICB0aGlzLmRyYXcodGhpcy5fcm9vdCwgc2NlbmUsIC0xKTtcbiAgICBET00uY2xlYXIodGhpcy5fcm9vdCwgMSk7XG4gIH1cbiAgdGhpcy51cGRhdGVEZWZzKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbihlbCwgc2NlbmUsIGluZGV4KSB7XG4gIHRoaXMuZHJhd01hcmsoZWwsIHNjZW5lLCBpbmRleCwgbWFya3Nbc2NlbmUubWFya3R5cGVdKTtcbn07XG5cblxuLy8gLS0gTWFuYWdlIFNWRyBkZWZpbml0aW9ucyAoJ2RlZnMnKSBibG9jayAtLVxuXG5wcm90b3R5cGUudXBkYXRlRGVmcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgZGVmcyA9IHRoaXMuX2RlZnMsXG4gICAgICBlbCA9IGRlZnMuZWwsXG4gICAgICBpbmRleCA9IDAsIGlkO1xuXG4gIGZvciAoaWQgaW4gZGVmcy5ncmFkaWVudCkge1xuICAgIGlmICghZWwpIGVsID0gKGRlZnMuZWwgPSBET00uY2hpbGQoc3ZnLCAwLCAnZGVmcycsIG5zKSk7XG4gICAgdXBkYXRlR3JhZGllbnQoZWwsIGRlZnMuZ3JhZGllbnRbaWRdLCBpbmRleCsrKTtcbiAgfVxuXG4gIGZvciAoaWQgaW4gZGVmcy5jbGlwcGluZykge1xuICAgIGlmICghZWwpIGVsID0gKGRlZnMuZWwgPSBET00uY2hpbGQoc3ZnLCAwLCAnZGVmcycsIG5zKSk7XG4gICAgdXBkYXRlQ2xpcHBpbmcoZWwsIGRlZnMuY2xpcHBpbmdbaWRdLCBpbmRleCsrKTtcbiAgfVxuXG4gIC8vIGNsZWFuLXVwXG4gIGlmIChlbCkge1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgc3ZnLnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgIGRlZnMuZWwgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBET00uY2xlYXIoZWwsIGluZGV4KTsgICAgICBcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZUdyYWRpZW50KGVsLCBncmFkLCBpbmRleCkge1xuICB2YXIgaSwgbiwgc3RvcDtcblxuICBlbCA9IERPTS5jaGlsZChlbCwgaW5kZXgsICdsaW5lYXJHcmFkaWVudCcsIG5zKTtcbiAgZWwuc2V0QXR0cmlidXRlKCdpZCcsIGdyYWQuaWQpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ3gxJywgZ3JhZC54MSk7XG4gIGVsLnNldEF0dHJpYnV0ZSgneDInLCBncmFkLngyKTtcbiAgZWwuc2V0QXR0cmlidXRlKCd5MScsIGdyYWQueTEpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ3kyJywgZ3JhZC55Mik7XG4gIFxuICBmb3IgKGk9MCwgbj1ncmFkLnN0b3BzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICBzdG9wID0gRE9NLmNoaWxkKGVsLCBpLCAnc3RvcCcsIG5zKTtcbiAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0JywgZ3JhZC5zdG9wc1tpXS5vZmZzZXQpO1xuICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywgZ3JhZC5zdG9wc1tpXS5jb2xvcik7XG4gIH1cbiAgRE9NLmNsZWFyKGVsLCBpKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2xpcHBpbmcoZWwsIGNsaXAsIGluZGV4KSB7XG4gIHZhciByZWN0O1xuXG4gIGVsID0gRE9NLmNoaWxkKGVsLCBpbmRleCwgJ2NsaXBQYXRoJywgbnMpO1xuICBlbC5zZXRBdHRyaWJ1dGUoJ2lkJywgY2xpcC5pZCk7XG4gIHJlY3QgPSBET00uY2hpbGQoZWwsIDAsICdyZWN0JywgbnMpO1xuICByZWN0LnNldEF0dHJpYnV0ZSgneCcsIDApO1xuICByZWN0LnNldEF0dHJpYnV0ZSgneScsIDApO1xuICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBjbGlwLndpZHRoKTtcbiAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGNsaXAuaGVpZ2h0KTtcbn1cblxucHJvdG90eXBlLl9yZXNldERlZnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRlZiA9IHRoaXMuX2RlZnM7XG4gIGRlZi5jbGlwX2lkID0gMTtcbiAgZGVmLmdyYWRpZW50ID0ge307XG4gIGRlZi5jbGlwcGluZyA9IHt9O1xufTtcblxuXG4vLyAtLSBNYW5hZ2UgcmVuZGVyaW5nIG9mIGl0ZW1zIG1hcmtlZCBhcyBkaXJ0eSAtLVxuXG5wcm90b3R5cGUuaXNEaXJ0eSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgcmV0dXJuIHRoaXMuX2RpcnR5QWxsIHx8IGl0ZW0uZGlydHkgPT09IHRoaXMuX2RpcnR5SUQ7XG59O1xuXG5wcm90b3R5cGUuX2RpcnR5Q2hlY2sgPSBmdW5jdGlvbihpdGVtcykge1xuICB0aGlzLl9kaXJ0eUFsbCA9IHRydWU7XG4gIGlmICghaXRlbXMpIHJldHVybiB0cnVlO1xuXG4gIHZhciBpZCA9ICsrdGhpcy5fZGlydHlJRCxcbiAgICAgIGl0ZW0sIG1hcmssIHR5cGUsIG1kZWYsIGksIG4sIG87XG5cbiAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBtYXJrID0gaXRlbS5tYXJrO1xuICAgIGlmIChtYXJrLm1hcmt0eXBlICE9PSB0eXBlKSB7XG4gICAgICAvLyBtZW1vaXplIG1hcmsgaW5zdGFuY2UgbG9va3VwXG4gICAgICB0eXBlID0gbWFyay5tYXJrdHlwZTtcbiAgICAgIG1kZWYgPSBtYXJrc1t0eXBlXTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbS5zdGF0dXMgPT09ICdleGl0JykgeyAvLyBFWElUXG4gICAgICBpZiAoaXRlbS5fc3ZnKSB7XG4gICAgICAgIGlmIChtZGVmLm5lc3QgJiYgaXRlbS5tYXJrLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGlmIG5lc3RlZCBtYXJrIHdpdGggcmVtYWluaW5nIHBvaW50cywgdXBkYXRlIGluc3RlYWRcbiAgICAgICAgICB0aGlzLl91cGRhdGUobWRlZiwgaXRlbS5fc3ZnLCBpdGVtLm1hcmsuaXRlbXNbMF0pO1xuICAgICAgICAgIG8gPSBpdGVtLm1hcmsuaXRlbXNbMF07XG4gICAgICAgICAgby5fc3ZnID0gaXRlbS5fc3ZnO1xuICAgICAgICAgIG8uX3VwZGF0ZSA9IGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG90aGVyd2lzZSByZW1vdmUgZnJvbSBET01cbiAgICAgICAgICBET00ucmVtb3ZlKGl0ZW0uX3N2Zyk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5fc3ZnID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGl0ZW0gPSAobWRlZi5uZXN0ID8gbWFyay5pdGVtc1swXSA6IGl0ZW0pO1xuICAgIGlmIChpdGVtLl91cGRhdGUgPT09IGlkKSB7IC8vIEFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0uX3N2ZykgeyAvLyBVUERBVEVcbiAgICAgIHRoaXMuX3VwZGF0ZShtZGVmLCBpdGVtLl9zdmcsIGl0ZW0pO1xuICAgIH0gZWxzZSB7IC8vIEVOVEVSXG4gICAgICB0aGlzLl9kaXJ0eUFsbCA9IGZhbHNlO1xuICAgICAgZGlydHlQYXJlbnRzKGl0ZW0sIGlkKTtcbiAgICB9XG4gICAgaXRlbS5fdXBkYXRlID0gaWQ7XG4gIH1cbiAgcmV0dXJuICF0aGlzLl9kaXJ0eUFsbDtcbn07XG5cbmZ1bmN0aW9uIGRpcnR5UGFyZW50cyhpdGVtLCBpZCkge1xuICBmb3IgKDsgaXRlbSAmJiBpdGVtLmRpcnR5ICE9PSBpZDsgaXRlbT1pdGVtLm1hcmsuZ3JvdXApIHtcbiAgICBpdGVtLmRpcnR5ID0gaWQ7XG4gICAgaWYgKGl0ZW0ubWFyayAmJiBpdGVtLm1hcmsuZGlydHkgIT09IGlkKSB7XG4gICAgICBpdGVtLm1hcmsuZGlydHkgPSBpZDtcbiAgICB9IGVsc2UgcmV0dXJuO1xuICB9XG59XG5cblxuLy8gLS0gQ29uc3RydWN0ICYgbWFpbnRhaW4gc2NlbmVncmFwaCB0byBTVkcgbWFwcGluZyAtLS1cblxuLy8gRHJhdyBhIG1hcmsgY29udGFpbmVyLlxucHJvdG90eXBlLmRyYXdNYXJrID0gZnVuY3Rpb24oZWwsIHNjZW5lLCBpbmRleCwgbWRlZikge1xuICBpZiAoIXRoaXMuaXNEaXJ0eShzY2VuZSkpIHJldHVybjtcblxuICB2YXIgaXRlbXMgPSBtZGVmLm5lc3QgP1xuICAgICAgICAoc2NlbmUuaXRlbXMgJiYgc2NlbmUuaXRlbXMubGVuZ3RoID8gW3NjZW5lLml0ZW1zWzBdXSA6IFtdKSA6XG4gICAgICAgIHNjZW5lLml0ZW1zIHx8IFtdLFxuICAgICAgZXZlbnRzID0gc2NlbmUuaW50ZXJhY3RpdmUgPT09IGZhbHNlID8gJ25vbmUnIDogbnVsbCxcbiAgICAgIGlzR3JvdXAgPSAobWRlZi50YWcgPT09ICdnJyksXG4gICAgICBjbGFzc05hbWUgPSBET00uY3NzQ2xhc3Moc2NlbmUpLFxuICAgICAgcCwgaSwgbiwgYywgZCwgaW5zZXJ0O1xuXG4gIHAgPSBET00uY2hpbGQoZWwsIGluZGV4KzEsICdnJywgbnMsIGNsYXNzTmFtZSk7XG4gIHAuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzTmFtZSk7XG4gIHNjZW5lLl9zdmcgPSBwO1xuICBpZiAoIWlzR3JvdXAgJiYgZXZlbnRzKSB7XG4gICAgcC5zdHlsZS5zZXRQcm9wZXJ0eSgncG9pbnRlci1ldmVudHMnLCBldmVudHMpO1xuICB9XG5cbiAgZm9yIChpPTAsIG49aXRlbXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGlmICh0aGlzLmlzRGlydHkoZCA9IGl0ZW1zW2ldKSkge1xuICAgICAgaW5zZXJ0ID0gISh0aGlzLl9kaXJ0eUFsbCB8fCBkLl9zdmcpO1xuICAgICAgYyA9IGJpbmQocCwgbWRlZiwgZCwgaSwgaW5zZXJ0KTtcbiAgICAgIHRoaXMuX3VwZGF0ZShtZGVmLCBjLCBkKTtcbiAgICAgIGlmIChpc0dyb3VwKSB7XG4gICAgICAgIGlmIChpbnNlcnQpIHRoaXMuX2RpcnR5QWxsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVjdXJzZShjLCBkKTtcbiAgICAgICAgaWYgKGluc2VydCkgdGhpcy5fZGlydHlBbGwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgRE9NLmNsZWFyKHAsIGkpO1xuICByZXR1cm4gcDtcbn07XG5cbi8vIFJlY3Vyc2l2ZWx5IHByb2Nlc3MgZ3JvdXAgY29udGVudHMuXG5wcm90b3R5cGUuX3JlY3Vyc2UgPSBmdW5jdGlvbihlbCwgZ3JvdXApIHtcbiAgdmFyIGl0ZW1zID0gZ3JvdXAuaXRlbXMgfHwgW10sXG4gICAgICBsZWdlbmRzID0gZ3JvdXAubGVnZW5kSXRlbXMgfHwgW10sXG4gICAgICBheGVzID0gZ3JvdXAuYXhpc0l0ZW1zIHx8IFtdLFxuICAgICAgaWR4ID0gMCwgaiwgbTtcblxuICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBpZiAoYXhlc1tqXS5sYXllciA9PT0gJ2JhY2snKSB7XG4gICAgICB0aGlzLmRyYXdNYXJrKGVsLCBheGVzW2pdLCBpZHgrKywgbWFya3MuZ3JvdXApO1xuICAgIH1cbiAgfVxuICBmb3IgKGo9MCwgbT1pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgdGhpcy5kcmF3KGVsLCBpdGVtc1tqXSwgaWR4KyspO1xuICB9XG4gIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGlmIChheGVzW2pdLmxheWVyICE9PSAnYmFjaycpIHtcbiAgICAgIHRoaXMuZHJhd01hcmsoZWwsIGF4ZXNbal0sIGlkeCsrLCBtYXJrcy5ncm91cCk7XG4gICAgfVxuICB9XG4gIGZvciAoaj0wLCBtPWxlZ2VuZHMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIHRoaXMuZHJhd01hcmsoZWwsIGxlZ2VuZHNbal0sIGlkeCsrLCBtYXJrcy5ncm91cCk7XG4gIH1cblxuICAvLyByZW1vdmUgYW55IGV4dHJhbmVvdXMgRE9NIGVsZW1lbnRzXG4gIERPTS5jbGVhcihlbCwgMSArIGlkeCk7XG59O1xuXG4vLyBCaW5kIGEgc2NlbmVncmFwaCBpdGVtIHRvIGFuIFNWRyBET00gZWxlbWVudC5cbi8vIENyZWF0ZSBuZXcgU1ZHIGVsZW1lbnRzIGFzIG5lZWRlZC5cbmZ1bmN0aW9uIGJpbmQoZWwsIG1kZWYsIGl0ZW0sIGluZGV4LCBpbnNlcnQpIHtcbiAgLy8gY3JlYXRlIHN2ZyBlbGVtZW50LCBiaW5kIGl0ZW0gZGF0YSBmb3IgRDMgY29tcGF0aWJpbGl0eVxuICB2YXIgbm9kZSA9IERPTS5jaGlsZChlbCwgaW5kZXgsIG1kZWYudGFnLCBucywgbnVsbCwgaW5zZXJ0KTtcbiAgbm9kZS5fX2RhdGFfXyA9IGl0ZW07XG4gIG5vZGUuX192YWx1ZXNfXyA9IHtmaWxsOiAnZGVmYXVsdCd9O1xuXG4gIC8vIGNyZWF0ZSBiYWNrZ3JvdW5kIHJlY3RcbiAgaWYgKG1kZWYudGFnID09PSAnZycpIHtcbiAgICB2YXIgYmcgPSBET00uY2hpbGQobm9kZSwgMCwgJ3JlY3QnLCBucywgJ2JhY2tncm91bmQnKTtcbiAgICBiZy5fX2RhdGFfXyA9IGl0ZW07XG4gIH1cblxuICAvLyBhZGQgcG9pbnRlciBmcm9tIHNjZW5lZ3JhcGggaXRlbSB0byBzdmcgZWxlbWVudFxuICByZXR1cm4gKGl0ZW0uX3N2ZyA9IG5vZGUpO1xufVxuXG5cbi8vIC0tIFNldCBhdHRyaWJ1dGVzICYgc3R5bGVzIG9uIFNWRyBlbGVtZW50cyAtLS1cblxudmFyIGVsZW1lbnQgPSBudWxsLCAvLyB0ZW1wIHZhciBmb3IgY3VycmVudCBTVkcgZWxlbWVudFxuICAgIHZhbHVlcyA9IG51bGw7ICAvLyB0ZW1wIHZhciBmb3IgY3VycmVudCB2YWx1ZXMgaGFzaFxuXG4vLyBFeHRyYSBjb25maWd1cmF0aW9uIGZvciBjZXJ0YWluIG1hcmsgdHlwZXNcbnZhciBtYXJrX2V4dHJhcyA9IHtcbiAgZ3JvdXA6IGZ1bmN0aW9uKG1kZWYsIGVsLCBpdGVtKSB7XG4gICAgZWxlbWVudCA9IGVsLmNoaWxkTm9kZXNbMF07XG4gICAgdmFsdWVzID0gZWwuX192YWx1ZXNfXzsgLy8gdXNlIHBhcmVudCdzIHZhbHVlcyBoYXNoXG4gICAgbWRlZi5iYWNrZ3JvdW5kKGVtaXQsIGl0ZW0sIHRoaXMpO1xuXG4gICAgdmFyIHZhbHVlID0gaXRlbS5tYXJrLmludGVyYWN0aXZlID09PSBmYWxzZSA/ICdub25lJyA6IG51bGw7XG4gICAgaWYgKHZhbHVlICE9PSB2YWx1ZXMuZXZlbnRzKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCdwb2ludGVyLWV2ZW50cycsIHZhbHVlKTtcbiAgICAgIHZhbHVlcy5ldmVudHMgPSB2YWx1ZTtcbiAgICB9XG4gIH0sXG4gIHRleHQ6IGZ1bmN0aW9uKG1kZWYsIGVsLCBpdGVtKSB7XG4gICAgdmFyIHN0ciA9IHRleHQudmFsdWUoaXRlbS50ZXh0KTtcbiAgICBpZiAoc3RyICE9PSB2YWx1ZXMudGV4dCkge1xuICAgICAgZWwudGV4dENvbnRlbnQgPSBzdHI7XG4gICAgICB2YWx1ZXMudGV4dCA9IHN0cjtcbiAgICB9XG4gICAgc3RyID0gdGV4dC5mb250KGl0ZW0pO1xuICAgIGlmIChzdHIgIT09IHZhbHVlcy5mb250KSB7XG4gICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eSgnZm9udCcsIHN0cik7XG4gICAgICB2YWx1ZXMuZm9udCA9IHN0cjtcbiAgICB9XG4gIH1cbn07XG5cbnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24obWRlZiwgZWwsIGl0ZW0pIHtcbiAgLy8gc2V0IGRvbSBlbGVtZW50IGFuZCB2YWx1ZXMgY2FjaGVcbiAgLy8gcHJvdmlkZXMgYWNjZXNzIHRvIGVtaXQgbWV0aG9kXG4gIGVsZW1lbnQgPSBlbDtcbiAgdmFsdWVzID0gZWwuX192YWx1ZXNfXztcblxuICAvLyBhcHBseSBzdmcgYXR0cmlidXRlc1xuICBtZGVmLmF0dHIoZW1pdCwgaXRlbSwgdGhpcyk7XG5cbiAgLy8gc29tZSBtYXJrcyBuZWVkIHNwZWNpYWwgdHJlYXRtZW50XG4gIHZhciBleHRyYSA9IG1hcmtfZXh0cmFzW21kZWYudHlwZV07XG4gIGlmIChleHRyYSkgZXh0cmEobWRlZiwgZWwsIGl0ZW0pO1xuXG4gIC8vIGFwcGx5IHN2ZyBjc3Mgc3R5bGVzXG4gIC8vIG5vdGU6IGVsZW1lbnQgbWF5IGJlIG1vZGlmaWVkIGJ5ICdleHRyYScgbWV0aG9kXG4gIHRoaXMuc3R5bGUoZWxlbWVudCwgaXRlbSk7XG59O1xuXG5mdW5jdGlvbiBlbWl0KG5hbWUsIHZhbHVlLCBucykge1xuICAvLyBlYXJseSBleGl0IGlmIHZhbHVlIGlzIHVuY2hhbmdlZFxuICBpZiAodmFsdWUgPT09IHZhbHVlc1tuYW1lXSkgcmV0dXJuO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gaWYgdmFsdWUgaXMgcHJvdmlkZWQsIHVwZGF0ZSBET00gYXR0cmlidXRlXG4gICAgaWYgKG5zKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG5zLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZWxzZSByZW1vdmUgRE9NIGF0dHJpYnV0ZVxuICAgIGlmIChucykge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGVOUyhucywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIG5vdGUgY3VycmVudCB2YWx1ZSBmb3IgZnV0dXJlIGNvbXBhcmlzb25cbiAgdmFsdWVzW25hbWVdID0gdmFsdWU7XG59XG5cbnByb3RvdHlwZS5zdHlsZSA9IGZ1bmN0aW9uKGVsLCBvKSB7XG4gIGlmIChvID09IG51bGwpIHJldHVybjtcbiAgdmFyIGksIG4sIHByb3AsIG5hbWUsIHZhbHVlO1xuXG4gIGZvciAoaT0wLCBuPVNWRy5zdHlsZVByb3BlcnRpZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHByb3AgPSBTVkcuc3R5bGVQcm9wZXJ0aWVzW2ldO1xuICAgIHZhbHVlID0gb1twcm9wXTtcbiAgICBpZiAodmFsdWUgPT09IHZhbHVlc1twcm9wXSkgY29udGludWU7XG5cbiAgICBuYW1lID0gU1ZHLnN0eWxlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgaWYgKG5hbWUgPT09ICdmaWxsJykge1xuICAgICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCAnbm9uZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWwuc3R5bGUucmVtb3ZlUHJvcGVydHkobmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZS5pZCkge1xuICAgICAgICAvLyBlbnN1cmUgZGVmaW5pdGlvbiBpcyBpbmNsdWRlZFxuICAgICAgICB0aGlzLl9kZWZzLmdyYWRpZW50W3ZhbHVlLmlkXSA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICd1cmwoJyArIGhyZWYoKSArICcjJyArIHZhbHVlLmlkICsgJyknO1xuICAgICAgfVxuICAgICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUrJycpO1xuICAgIH1cblxuICAgIHZhbHVlc1twcm9wXSA9IHZhbHVlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBocmVmKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6ICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNWR1JlbmRlcmVyO1xuIiwidmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vUmVuZGVyZXInKSxcbiAgICBJbWFnZUxvYWRlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvSW1hZ2VMb2FkZXInKSxcbiAgICBTVkcgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N2ZycpLFxuICAgIHRleHQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RleHQnKSxcbiAgICBET00gPSByZXF1aXJlKCcuLi8uLi91dGlsL2RvbScpLFxuICAgIG9wZW5UYWcgPSBET00ub3BlblRhZyxcbiAgICBjbG9zZVRhZyA9IERPTS5jbG9zZVRhZyxcbiAgICBNQVJLUyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxuZnVuY3Rpb24gU1ZHU3RyaW5nUmVuZGVyZXIobG9hZENvbmZpZykge1xuICBSZW5kZXJlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuX2xvYWRlciA9IG5ldyBJbWFnZUxvYWRlcihsb2FkQ29uZmlnKTtcblxuICB0aGlzLl90ZXh0ID0ge1xuICAgIGhlYWQ6ICcnLFxuICAgIHJvb3Q6ICcnLFxuICAgIGZvb3Q6ICcnLFxuICAgIGRlZnM6ICcnLFxuICAgIGJvZHk6ICcnXG4gIH07XG5cbiAgdGhpcy5fZGVmcyA9IHtcbiAgICBjbGlwX2lkOiAgMSxcbiAgICBncmFkaWVudDoge30sXG4gICAgY2xpcHBpbmc6IHt9XG4gIH07XG59XG5cbnZhciBiYXNlID0gUmVuZGVyZXIucHJvdG90eXBlO1xudmFyIHByb3RvdHlwZSA9IChTVkdTdHJpbmdSZW5kZXJlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2UpKTtcbnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNWR1N0cmluZ1JlbmRlcmVyO1xuXG5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICBiYXNlLnJlc2l6ZS5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpO1xuICB2YXIgcCA9IHRoaXMuX3BhZGRpbmcsXG4gICAgICB0ID0gdGhpcy5fdGV4dDtcblxuICB2YXIgYXR0ciA9IHtcbiAgICAnY2xhc3MnOiAgJ21hcmtzJyxcbiAgICAnd2lkdGgnOiAgdGhpcy5fd2lkdGggKyBwLmxlZnQgKyBwLnJpZ2h0LFxuICAgICdoZWlnaHQnOiB0aGlzLl9oZWlnaHQgKyBwLnRvcCArIHAuYm90dG9tLFxuICB9O1xuICBmb3IgKHZhciBrZXkgaW4gU1ZHLm1ldGFkYXRhKSB7XG4gICAgYXR0cltrZXldID0gU1ZHLm1ldGFkYXRhW2tleV07XG4gIH1cblxuICB0LmhlYWQgPSBvcGVuVGFnKCdzdmcnLCBhdHRyKTtcbiAgdC5yb290ID0gb3BlblRhZygnZycsIHtcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoJyArIHAubGVmdCArICcsJyArIHAudG9wICsgJyknXG4gIH0pO1xuICB0LmZvb3QgPSBjbG9zZVRhZygnZycpICsgY2xvc2VUYWcoJ3N2ZycpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnN2ZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMuX3RleHQ7XG4gIHJldHVybiB0LmhlYWQgKyB0LmRlZnMgKyB0LnJvb3QgKyB0LmJvZHkgKyB0LmZvb3Q7XG59O1xuXG5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdGhpcy5fdGV4dC5ib2R5ID0gdGhpcy5tYXJrKHNjZW5lKTtcbiAgdGhpcy5fdGV4dC5kZWZzID0gdGhpcy5idWlsZERlZnMoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fZGVmcy5jbGlwX2lkID0gMDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuYnVpbGREZWZzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhbGwgPSB0aGlzLl9kZWZzLFxuICAgICAgZGVmcyA9ICcnLFxuICAgICAgaSwgaWQsIGRlZiwgc3RvcHM7XG5cbiAgZm9yIChpZCBpbiBhbGwuZ3JhZGllbnQpIHtcbiAgICBkZWYgPSBhbGwuZ3JhZGllbnRbaWRdO1xuICAgIHN0b3BzID0gZGVmLnN0b3BzO1xuXG4gICAgZGVmcyArPSBvcGVuVGFnKCdsaW5lYXJHcmFkaWVudCcsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIHgxOiBkZWYueDEsXG4gICAgICB4MjogZGVmLngyLFxuICAgICAgeTE6IGRlZi55MSxcbiAgICAgIHkyOiBkZWYueTJcbiAgICB9KTtcbiAgICBcbiAgICBmb3IgKGk9MDsgaTxzdG9wcy5sZW5ndGg7ICsraSkge1xuICAgICAgZGVmcyArPSBvcGVuVGFnKCdzdG9wJywge1xuICAgICAgICBvZmZzZXQ6IHN0b3BzW2ldLm9mZnNldCxcbiAgICAgICAgJ3N0b3AtY29sb3InOiBzdG9wc1tpXS5jb2xvclxuICAgICAgfSkgKyBjbG9zZVRhZygnc3RvcCcpO1xuICAgIH1cbiAgICBcbiAgICBkZWZzICs9IGNsb3NlVGFnKCdsaW5lYXJHcmFkaWVudCcpO1xuICB9XG4gIFxuICBmb3IgKGlkIGluIGFsbC5jbGlwcGluZykge1xuICAgIGRlZiA9IGFsbC5jbGlwcGluZ1tpZF07XG5cbiAgICBkZWZzICs9IG9wZW5UYWcoJ2NsaXBQYXRoJywge2lkOiBpZH0pO1xuXG4gICAgZGVmcyArPSBvcGVuVGFnKCdyZWN0Jywge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogZGVmLndpZHRoLFxuICAgICAgaGVpZ2h0OiBkZWYuaGVpZ2h0XG4gICAgfSkgKyBjbG9zZVRhZygncmVjdCcpO1xuXG4gICAgZGVmcyArPSBjbG9zZVRhZygnY2xpcFBhdGgnKTtcbiAgfVxuICBcbiAgcmV0dXJuIChkZWZzLmxlbmd0aCA+IDApID8gb3BlblRhZygnZGVmcycpICsgZGVmcyArIGNsb3NlVGFnKCdkZWZzJykgOiAnJztcbn07XG5cbnByb3RvdHlwZS5pbWFnZVVSTCA9IGZ1bmN0aW9uKHVybCkge1xuICByZXR1cm4gdGhpcy5fbG9hZGVyLmltYWdlVVJMKHVybCk7XG59O1xuXG52YXIgb2JqZWN0O1xuXG5mdW5jdGlvbiBlbWl0KG5hbWUsIHZhbHVlLCBucywgcHJlZml4ZWQpIHtcbiAgb2JqZWN0W3ByZWZpeGVkIHx8IG5hbWVdID0gdmFsdWU7XG59XG5cbnByb3RvdHlwZS5hdHRyaWJ1dGVzID0gZnVuY3Rpb24oYXR0ciwgaXRlbSkge1xuICBvYmplY3QgPSB7fTtcbiAgYXR0cihlbWl0LCBpdGVtLCB0aGlzKTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbnByb3RvdHlwZS5tYXJrID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdmFyIG1kZWYgPSBNQVJLU1tzY2VuZS5tYXJrdHlwZV0sXG4gICAgICB0YWcgID0gbWRlZi50YWcsXG4gICAgICBhdHRyID0gbWRlZi5hdHRyLFxuICAgICAgbmVzdCA9IG1kZWYubmVzdCB8fCBmYWxzZSxcbiAgICAgIGRhdGEgPSBuZXN0ID9cbiAgICAgICAgICAoc2NlbmUuaXRlbXMgJiYgc2NlbmUuaXRlbXMubGVuZ3RoID8gW3NjZW5lLml0ZW1zWzBdXSA6IFtdKSA6XG4gICAgICAgICAgKHNjZW5lLml0ZW1zIHx8IFtdKSxcbiAgICAgIGRlZnMgPSB0aGlzLl9kZWZzLFxuICAgICAgc3RyID0gJycsXG4gICAgICBzdHlsZSwgaSwgaXRlbTtcblxuICBpZiAodGFnICE9PSAnZycgJiYgc2NlbmUuaW50ZXJhY3RpdmUgPT09IGZhbHNlKSB7XG4gICAgc3R5bGUgPSAnc3R5bGU9XCJwb2ludGVyLWV2ZW50czogbm9uZTtcIic7XG4gIH1cblxuICAvLyByZW5kZXIgb3BlbmluZyBncm91cCB0YWdcbiAgc3RyICs9IG9wZW5UYWcoJ2cnLCB7XG4gICAgJ2NsYXNzJzogRE9NLmNzc0NsYXNzKHNjZW5lKVxuICB9LCBzdHlsZSk7XG5cbiAgLy8gcmVuZGVyIGNvbnRhaW5lZCBlbGVtZW50c1xuICBmb3IgKGk9MDsgaTxkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgaXRlbSA9IGRhdGFbaV07XG4gICAgc3R5bGUgPSAodGFnICE9PSAnZycpID8gc3R5bGVzKGl0ZW0sIHNjZW5lLCB0YWcsIGRlZnMpIDogbnVsbDtcbiAgICBzdHIgKz0gb3BlblRhZyh0YWcsIHRoaXMuYXR0cmlidXRlcyhhdHRyLCBpdGVtKSwgc3R5bGUpO1xuICAgIGlmICh0YWcgPT09ICd0ZXh0Jykge1xuICAgICAgc3RyICs9IGVzY2FwZV90ZXh0KHRleHQudmFsdWUoaXRlbS50ZXh0KSk7XG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICdnJykge1xuICAgICAgc3RyICs9IG9wZW5UYWcoJ3JlY3QnLFxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMobWRlZi5iYWNrZ3JvdW5kLCBpdGVtKSxcbiAgICAgICAgc3R5bGVzKGl0ZW0sIHNjZW5lLCAnYmdyZWN0JywgZGVmcykpICsgY2xvc2VUYWcoJ3JlY3QnKTtcbiAgICAgIHN0ciArPSB0aGlzLm1hcmtHcm91cChpdGVtKTtcbiAgICB9XG4gICAgc3RyICs9IGNsb3NlVGFnKHRhZyk7XG4gIH1cblxuICAvLyByZW5kZXIgY2xvc2luZyBncm91cCB0YWdcbiAgcmV0dXJuIHN0ciArIGNsb3NlVGFnKCdnJyk7XG59O1xuXG5wcm90b3R5cGUubWFya0dyb3VwID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgdmFyIHN0ciA9ICcnLFxuICAgICAgYXhlcyA9IHNjZW5lLmF4aXNJdGVtcyB8fCBbXSxcbiAgICAgIGl0ZW1zID0gc2NlbmUuaXRlbXMgfHwgW10sXG4gICAgICBsZWdlbmRzID0gc2NlbmUubGVnZW5kSXRlbXMgfHwgW10sXG4gICAgICBqLCBtO1xuXG4gIGZvciAoaj0wLCBtPWF4ZXMubGVuZ3RoOyBqPG07ICsraikge1xuICAgIGlmIChheGVzW2pdLmxheWVyID09PSAnYmFjaycpIHtcbiAgICAgIHN0ciArPSB0aGlzLm1hcmsoYXhlc1tqXSk7XG4gICAgfVxuICB9XG4gIGZvciAoaj0wLCBtPWl0ZW1zLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBzdHIgKz0gdGhpcy5tYXJrKGl0ZW1zW2pdKTtcbiAgfVxuICBmb3IgKGo9MCwgbT1heGVzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBpZiAoYXhlc1tqXS5sYXllciAhPT0gJ2JhY2snKSB7XG4gICAgICBzdHIgKz0gdGhpcy5tYXJrKGF4ZXNbal0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICBzdHIgKz0gdGhpcy5tYXJrKGxlZ2VuZHNbal0pO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbmZ1bmN0aW9uIHN0eWxlcyhvLCBtYXJrLCB0YWcsIGRlZnMpIHtcbiAgaWYgKG8gPT0gbnVsbCkgcmV0dXJuICcnO1xuICB2YXIgaSwgbiwgcHJvcCwgbmFtZSwgdmFsdWUsIHMgPSAnJztcblxuICBpZiAodGFnID09PSAnYmdyZWN0JyAmJiBtYXJrLmludGVyYWN0aXZlID09PSBmYWxzZSkge1xuICAgIHMgKz0gJ3BvaW50ZXItZXZlbnRzOiBub25lOyc7XG4gIH1cblxuICBpZiAodGFnID09PSAndGV4dCcpIHtcbiAgICBzICs9ICdmb250OiAnICsgdGV4dC5mb250KG8pICsgJzsnO1xuICB9XG5cbiAgZm9yIChpPTAsIG49U1ZHLnN0eWxlUHJvcGVydGllcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgcHJvcCA9IFNWRy5zdHlsZVByb3BlcnRpZXNbaV07XG4gICAgbmFtZSA9IFNWRy5zdHlsZXNbcHJvcF07XG4gICAgdmFsdWUgPSBvW3Byb3BdO1xuXG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGlmIChuYW1lID09PSAnZmlsbCcpIHtcbiAgICAgICAgcyArPSAocy5sZW5ndGggPyAnICcgOiAnJykgKyAnZmlsbDogbm9uZTsnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUuaWQpIHtcbiAgICAgICAgLy8gZW5zdXJlIGRlZmluaXRpb24gaXMgaW5jbHVkZWRcbiAgICAgICAgZGVmcy5ncmFkaWVudFt2YWx1ZS5pZF0gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAndXJsKCMnICsgdmFsdWUuaWQgKyAnKSc7XG4gICAgICB9XG4gICAgICBzICs9IChzLmxlbmd0aCA/ICcgJyA6ICcnKSArIG5hbWUgKyAnOiAnICsgdmFsdWUgKyAnOyc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHMgPyAnc3R5bGU9XCInICsgcyArICdcIicgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVfdGV4dChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTVkdTdHJpbmdSZW5kZXJlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBIYW5kbGVyOiAgcmVxdWlyZSgnLi9TVkdIYW5kbGVyJyksXG4gIFJlbmRlcmVyOiByZXF1aXJlKCcuL1NWR1JlbmRlcmVyJyksXG4gIHN0cmluZzoge1xuICAgIFJlbmRlcmVyIDogcmVxdWlyZSgnLi9TVkdTdHJpbmdSZW5kZXJlcicpXG4gIH1cbn07IiwidmFyIHRleHQgPSByZXF1aXJlKCcuLi8uLi91dGlsL3RleHQnKSxcbiAgICBTVkcgPSByZXF1aXJlKCcuLi8uLi91dGlsL3N2ZycpLFxuICAgIHRleHRBbGlnbiA9IFNWRy50ZXh0QWxpZ24sXG4gICAgcGF0aCA9IFNWRy5wYXRoO1xuXG5mdW5jdGlvbiB0cmFuc2xhdGVJdGVtKG8pIHtcbiAgcmV0dXJuIHRyYW5zbGF0ZShvLnggfHwgMCwgby55IHx8IDApO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGUoeCwgeSkge1xuICByZXR1cm4gJ3RyYW5zbGF0ZSgnICsgeCArICcsJyArIHkgKyAnKSc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcmM6IHtcbiAgICB0YWc6ICAncGF0aCcsXG4gICAgdHlwZTogJ2FyYycsXG4gICAgYXR0cjogZnVuY3Rpb24oZW1pdCwgbykge1xuICAgICAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlSXRlbShvKSk7XG4gICAgICBlbWl0KCdkJywgcGF0aC5hcmMobykpO1xuICAgIH1cbiAgfSxcbiAgYXJlYToge1xuICAgIHRhZzogICdwYXRoJyxcbiAgICB0eXBlOiAnYXJlYScsXG4gICAgbmVzdDogdHJ1ZSxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvKSB7XG4gICAgICB2YXIgaXRlbXMgPSBvLm1hcmsuaXRlbXM7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSBlbWl0KCdkJywgcGF0aC5hcmVhKGl0ZW1zKSk7XG4gICAgfVxuICB9LFxuICBncm91cDoge1xuICAgIHRhZzogICdnJyxcbiAgICB0eXBlOiAnZ3JvdXAnLFxuICAgIGF0dHI6IGZ1bmN0aW9uKGVtaXQsIG8sIHJlbmRlcmVyKSB7XG4gICAgICB2YXIgaWQgPSBudWxsLCBkZWZzLCBjO1xuICAgICAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlSXRlbShvKSk7XG4gICAgICBpZiAoby5jbGlwKSB7XG4gICAgICAgIGRlZnMgPSByZW5kZXJlci5fZGVmcztcbiAgICAgICAgaWQgPSBvLmNsaXBfaWQgfHwgKG8uY2xpcF9pZCA9ICdjbGlwJyArIGRlZnMuY2xpcF9pZCsrKTtcbiAgICAgICAgYyA9IGRlZnMuY2xpcHBpbmdbaWRdIHx8IChkZWZzLmNsaXBwaW5nW2lkXSA9IHtpZDogaWR9KTtcbiAgICAgICAgYy53aWR0aCA9IG8ud2lkdGggfHwgMDtcbiAgICAgICAgYy5oZWlnaHQgPSBvLmhlaWdodCB8fCAwO1xuICAgICAgfVxuICAgICAgZW1pdCgnY2xpcC1wYXRoJywgaWQgPyAoJ3VybCgjJyArIGlkICsgJyknKSA6IG51bGwpO1xuICAgIH0sXG4gICAgYmFja2dyb3VuZDogZnVuY3Rpb24oZW1pdCwgbykge1xuICAgICAgZW1pdCgnY2xhc3MnLCAnYmFja2dyb3VuZCcpO1xuICAgICAgZW1pdCgnd2lkdGgnLCBvLndpZHRoIHx8IDApO1xuICAgICAgZW1pdCgnaGVpZ2h0Jywgby5oZWlnaHQgfHwgMCk7XG4gICAgfVxuICB9LFxuICBpbWFnZToge1xuICAgIHRhZzogICdpbWFnZScsXG4gICAgdHlwZTogJ2ltYWdlJyxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvLCByZW5kZXJlcikge1xuICAgICAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgICAgICB5ID0gby55IHx8IDAsXG4gICAgICAgICAgdyA9IG8ud2lkdGggfHwgMCxcbiAgICAgICAgICBoID0gby5oZWlnaHQgfHwgMCxcbiAgICAgICAgICB1cmwgPSByZW5kZXJlci5pbWFnZVVSTChvLnVybCk7XG5cbiAgICAgIHggPSB4IC0gKG8uYWxpZ24gPT09ICdjZW50ZXInID8gdy8yIDogby5hbGlnbiA9PT0gJ3JpZ2h0JyA/IHcgOiAwKTtcbiAgICAgIHkgPSB5IC0gKG8uYmFzZWxpbmUgPT09ICdtaWRkbGUnID8gaC8yIDogby5iYXNlbGluZSA9PT0gJ2JvdHRvbScgPyBoIDogMCk7XG5cbiAgICAgIGVtaXQoJ2hyZWYnLCB1cmwsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ3hsaW5rOmhyZWYnKTtcbiAgICAgIGVtaXQoJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZSh4LCB5KSk7XG4gICAgICBlbWl0KCd3aWR0aCcsIHcpO1xuICAgICAgZW1pdCgnaGVpZ2h0JywgaCk7XG4gICAgfVxuICB9LFxuICBsaW5lOiB7XG4gICAgdGFnOiAgJ3BhdGgnLFxuICAgIHR5cGU6ICdsaW5lJyxcbiAgICBuZXN0OiB0cnVlLFxuICAgIGF0dHI6IGZ1bmN0aW9uKGVtaXQsIG8pIHtcbiAgICAgIHZhciBpdGVtcyA9IG8ubWFyay5pdGVtcztcbiAgICAgIGlmIChpdGVtcy5sZW5ndGgpIGVtaXQoJ2QnLCBwYXRoLmxpbmUoaXRlbXMpKTtcbiAgICB9XG4gIH0sXG4gIHBhdGg6IHtcbiAgICB0YWc6ICAncGF0aCcsXG4gICAgdHlwZTogJ3BhdGgnLFxuICAgIGF0dHI6IGZ1bmN0aW9uKGVtaXQsIG8pIHtcbiAgICAgIGVtaXQoJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZUl0ZW0obykpO1xuICAgICAgZW1pdCgnZCcsIG8ucGF0aCk7XG4gICAgfVxuICB9LFxuICByZWN0OiB7XG4gICAgdGFnOiAgJ3JlY3QnLFxuICAgIHR5cGU6ICdyZWN0JyxcbiAgICBuZXN0OiBmYWxzZSxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvKSB7XG4gICAgICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2xhdGVJdGVtKG8pKTtcbiAgICAgIGVtaXQoJ3dpZHRoJywgby53aWR0aCB8fCAwKTtcbiAgICAgIGVtaXQoJ2hlaWdodCcsIG8uaGVpZ2h0IHx8IDApO1xuICAgIH1cbiAgfSxcbiAgcnVsZToge1xuICAgIHRhZzogICdsaW5lJyxcbiAgICB0eXBlOiAncnVsZScsXG4gICAgYXR0cjogZnVuY3Rpb24oZW1pdCwgbykge1xuICAgICAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlSXRlbShvKSk7XG4gICAgICBlbWl0KCd4MicsIG8ueDIgIT0gbnVsbCA/IG8ueDIgLSAoby54fHwwKSA6IDApO1xuICAgICAgZW1pdCgneTInLCBvLnkyICE9IG51bGwgPyBvLnkyIC0gKG8ueXx8MCkgOiAwKTtcbiAgICB9XG4gIH0sXG4gIHN5bWJvbDoge1xuICAgIHRhZzogICdwYXRoJyxcbiAgICB0eXBlOiAnc3ltYm9sJyxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvKSB7XG4gICAgICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2xhdGVJdGVtKG8pKTtcbiAgICAgIGVtaXQoJ2QnLCBwYXRoLnN5bWJvbChvKSk7XG4gICAgfVxuICB9LFxuICB0ZXh0OiB7XG4gICAgdGFnOiAgJ3RleHQnLFxuICAgIHR5cGU6ICd0ZXh0JyxcbiAgICBuZXN0OiBmYWxzZSxcbiAgICBhdHRyOiBmdW5jdGlvbihlbWl0LCBvKSB7XG4gICAgICB2YXIgZHggPSAoby5keCB8fCAwKSxcbiAgICAgICAgICBkeSA9IChvLmR5IHx8IDApICsgdGV4dC5vZmZzZXQobyksXG4gICAgICAgICAgeCA9IChvLnggfHwgMCksXG4gICAgICAgICAgeSA9IChvLnkgfHwgMCksXG4gICAgICAgICAgYSA9IG8uYW5nbGUgfHwgMCxcbiAgICAgICAgICByID0gby5yYWRpdXMgfHwgMCwgdDtcblxuICAgICAgaWYgKHIpIHtcbiAgICAgICAgdCA9IChvLnRoZXRhIHx8IDApIC0gTWF0aC5QSS8yO1xuICAgICAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICAgICAgeSArPSByICogTWF0aC5zaW4odCk7XG4gICAgICB9XG5cbiAgICAgIGVtaXQoJ3RleHQtYW5jaG9yJywgdGV4dEFsaWduW28uYWxpZ25dIHx8ICdzdGFydCcpO1xuICAgICAgXG4gICAgICBpZiAoYSkge1xuICAgICAgICB0ID0gdHJhbnNsYXRlKHgsIHkpICsgJyByb3RhdGUoJythKycpJztcbiAgICAgICAgaWYgKGR4IHx8IGR5KSB0ICs9ICcgJyArIHRyYW5zbGF0ZShkeCwgZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHRyYW5zbGF0ZSh4K2R4LCB5K2R5KTtcbiAgICAgIH1cbiAgICAgIGVtaXQoJ3RyYW5zZm9ybScsIHQpO1xuICAgIH1cbiAgfVxufTtcbiIsImZ1bmN0aW9uIEJvdW5kcyhiKSB7XG4gIHRoaXMuY2xlYXIoKTtcbiAgaWYgKGIpIHRoaXMudW5pb24oYik7XG59XG5cbnZhciBwcm90b3R5cGUgPSBCb3VuZHMucHJvdG90eXBlO1xuXG5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBCb3VuZHModGhpcyk7XG59O1xuXG5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy54MSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICB0aGlzLnkxID0gK051bWJlci5NQVhfVkFMVUU7XG4gIHRoaXMueDIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgdGhpcy55MiA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICB0aGlzLngxID0geDE7XG4gIHRoaXMueTEgPSB5MTtcbiAgdGhpcy54MiA9IHgyO1xuICB0aGlzLnkyID0geTI7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgaWYgKHggPCB0aGlzLngxKSB0aGlzLngxID0geDtcbiAgaWYgKHkgPCB0aGlzLnkxKSB0aGlzLnkxID0geTtcbiAgaWYgKHggPiB0aGlzLngyKSB0aGlzLngyID0geDtcbiAgaWYgKHkgPiB0aGlzLnkyKSB0aGlzLnkyID0geTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24oZCkge1xuICB0aGlzLngxIC09IGQ7XG4gIHRoaXMueTEgLT0gZDtcbiAgdGhpcy54MiArPSBkO1xuICB0aGlzLnkyICs9IGQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJvdW5kID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMueDEgPSBNYXRoLmZsb29yKHRoaXMueDEpO1xuICB0aGlzLnkxID0gTWF0aC5mbG9vcih0aGlzLnkxKTtcbiAgdGhpcy54MiA9IE1hdGguY2VpbCh0aGlzLngyKTtcbiAgdGhpcy55MiA9IE1hdGguY2VpbCh0aGlzLnkyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90b3R5cGUudHJhbnNsYXRlID0gZnVuY3Rpb24oZHgsIGR5KSB7XG4gIHRoaXMueDEgKz0gZHg7XG4gIHRoaXMueDIgKz0gZHg7XG4gIHRoaXMueTEgKz0gZHk7XG4gIHRoaXMueTIgKz0gZHk7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKGFuZ2xlLCB4LCB5KSB7XG4gIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG4gICAgICBzaW4gPSBNYXRoLnNpbihhbmdsZSksXG4gICAgICBjeCA9IHggLSB4KmNvcyArIHkqc2luLFxuICAgICAgY3kgPSB5IC0geCpzaW4gLSB5KmNvcyxcbiAgICAgIHgxID0gdGhpcy54MSwgeDIgPSB0aGlzLngyLFxuICAgICAgeTEgPSB0aGlzLnkxLCB5MiA9IHRoaXMueTI7XG5cbiAgcmV0dXJuIHRoaXMuY2xlYXIoKVxuICAgIC5hZGQoY29zKngxIC0gc2luKnkxICsgY3gsICBzaW4qeDEgKyBjb3MqeTEgKyBjeSlcbiAgICAuYWRkKGNvcyp4MSAtIHNpbip5MiArIGN4LCAgc2luKngxICsgY29zKnkyICsgY3kpXG4gICAgLmFkZChjb3MqeDIgLSBzaW4qeTEgKyBjeCwgIHNpbip4MiArIGNvcyp5MSArIGN5KVxuICAgIC5hZGQoY29zKngyIC0gc2luKnkyICsgY3gsICBzaW4qeDIgKyBjb3MqeTIgKyBjeSk7XG59O1xuXG5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbihiKSB7XG4gIGlmIChiLngxIDwgdGhpcy54MSkgdGhpcy54MSA9IGIueDE7XG4gIGlmIChiLnkxIDwgdGhpcy55MSkgdGhpcy55MSA9IGIueTE7XG4gIGlmIChiLngyID4gdGhpcy54MikgdGhpcy54MiA9IGIueDI7XG4gIGlmIChiLnkyID4gdGhpcy55MikgdGhpcy55MiA9IGIueTI7XG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG90eXBlLmVuY2xvc2VzID0gZnVuY3Rpb24oYikge1xuICByZXR1cm4gYiAmJiAoXG4gICAgdGhpcy54MSA8PSBiLngxICYmXG4gICAgdGhpcy54MiA+PSBiLngyICYmXG4gICAgdGhpcy55MSA8PSBiLnkxICYmXG4gICAgdGhpcy55MiA+PSBiLnkyXG4gICk7XG59O1xuXG5wcm90b3R5cGUuYWxpZ25zV2l0aCA9IGZ1bmN0aW9uKGIpIHtcbiAgcmV0dXJuIGIgJiYgKFxuICAgIHRoaXMueDEgPT0gYi54MSB8fFxuICAgIHRoaXMueDIgPT0gYi54MiB8fFxuICAgIHRoaXMueTEgPT0gYi55MSB8fFxuICAgIHRoaXMueTIgPT0gYi55MlxuICApO1xufTtcblxucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbihiKSB7XG4gIHJldHVybiBiICYmICEoXG4gICAgdGhpcy54MiA8IGIueDEgfHxcbiAgICB0aGlzLngxID4gYi54MiB8fFxuICAgIHRoaXMueTIgPCBiLnkxIHx8XG4gICAgdGhpcy55MSA+IGIueTJcbiAgKTtcbn07XG5cbnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuICEoXG4gICAgeCA8IHRoaXMueDEgfHxcbiAgICB4ID4gdGhpcy54MiB8fFxuICAgIHkgPCB0aGlzLnkxIHx8XG4gICAgeSA+IHRoaXMueTJcbiAgKTtcbn07XG5cbnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy54MiAtIHRoaXMueDE7XG59O1xuXG5wcm90b3R5cGUuaGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnkyIC0gdGhpcy55MTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQm91bmRzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihiKSB7XG4gIGZ1bmN0aW9uIG5vb3AoKSB7IH1cbiAgZnVuY3Rpb24gYWRkKHgseSkgeyBiLmFkZCh4LCB5KTsgfVxuXG4gIHJldHVybiB7XG4gICAgYm91bmRzOiBmdW5jdGlvbihfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiO1xuICAgICAgcmV0dXJuIChiID0gXywgdGhpcyk7XG4gICAgfSxcbiAgICBiZWdpblBhdGg6IG5vb3AsXG4gICAgY2xvc2VQYXRoOiBub29wLFxuICAgIG1vdmVUbzogYWRkLFxuICAgIGxpbmVUbzogYWRkLFxuICAgIHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgICBiLmFkZCh4MSwgeTEpO1xuICAgICAgYi5hZGQoeDIsIHkyKTtcbiAgICB9LFxuICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICAgIGIuYWRkKHgxLCB5MSk7XG4gICAgICBiLmFkZCh4MiwgeTIpO1xuICAgICAgYi5hZGQoeDMsIHkzKTtcbiAgICB9XG4gIH07XG59O1xuIiwidmFyIGdyYWRpZW50X2lkID0gMDtcblxuZnVuY3Rpb24gR3JhZGllbnQodHlwZSkge1xuICB0aGlzLmlkID0gJ2dyYWRpZW50XycgKyAoZ3JhZGllbnRfaWQrKyk7XG4gIHRoaXMudHlwZSA9IHR5cGUgfHwgJ2xpbmVhcic7XG4gIHRoaXMuc3RvcHMgPSBbXTtcbiAgdGhpcy54MSA9IDA7XG4gIHRoaXMueDIgPSAxO1xuICB0aGlzLnkxID0gMDtcbiAgdGhpcy55MiA9IDA7XG59XG5cbnZhciBwcm90b3R5cGUgPSBHcmFkaWVudC5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24ob2Zmc2V0LCBjb2xvcikge1xuICB0aGlzLnN0b3BzLnB1c2goe1xuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIGNvbG9yOiBjb2xvclxuICB9KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYWRpZW50OyIsInZhciBsb2FkID0gcmVxdWlyZSgnZGF0YWxpYi9zcmMvaW1wb3J0L2xvYWQnKTtcblxuZnVuY3Rpb24gSW1hZ2VMb2FkZXIobG9hZENvbmZpZykge1xuICB0aGlzLl9wZW5kaW5nID0gMDtcbiAgdGhpcy5fY29uZmlnID0gbG9hZENvbmZpZyB8fCBJbWFnZUxvYWRlci5Db25maWc7IFxufVxuXG4vLyBPdmVycmlkYWJsZSBnbG9iYWwgZGVmYXVsdCBsb2FkIGNvbmZpZ3VyYXRpb25cbkltYWdlTG9hZGVyLkNvbmZpZyA9IG51bGw7XG5cbnZhciBwcm90b3R5cGUgPSBJbWFnZUxvYWRlci5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5wZW5kaW5nID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9wZW5kaW5nO1xufTtcblxucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uKHVyaSkge1xuICB2YXIgcCA9IHt1cmw6IHVyaX0sIGs7XG4gIGZvciAoayBpbiB0aGlzLl9jb25maWcpIHsgcFtrXSA9IHRoaXMuX2NvbmZpZ1trXTsgfVxuICByZXR1cm4gcDtcbn07XG5cbnByb3RvdHlwZS5pbWFnZVVSTCA9IGZ1bmN0aW9uKHVyaSkge1xuICByZXR1cm4gbG9hZC5zYW5pdGl6ZVVybCh0aGlzLnBhcmFtcyh1cmkpKTtcbn07XG5cbmZ1bmN0aW9uIGJyb3dzZXIodXJpLCBjYWxsYmFjaykge1xuICB2YXIgdXJsID0gbG9hZC5zYW5pdGl6ZVVybCh0aGlzLnBhcmFtcyh1cmkpKTtcbiAgaWYgKCF1cmwpIHsgLy8gZXJyb3JcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKHVyaSwgbnVsbCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbG9hZGVyID0gdGhpcyxcbiAgICAgIGltYWdlID0gbmV3IEltYWdlKCk7XG5cbiAgbG9hZGVyLl9wZW5kaW5nICs9IDE7XG5cbiAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgbG9hZGVyLl9wZW5kaW5nIC09IDE7XG4gICAgaW1hZ2UubG9hZGVkID0gdHJ1ZTtcbiAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG51bGwsIGltYWdlKTtcbiAgfTtcbiAgaW1hZ2Uuc3JjID0gdXJsO1xuXG4gIHJldHVybiBpbWFnZTtcbn1cblxuZnVuY3Rpb24gc2VydmVyKHVyaSwgY2FsbGJhY2spIHtcbiAgdmFyIGxvYWRlciA9IHRoaXMsXG4gICAgICBpbWFnZSA9IG5ldyAoKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2NhbnZhcyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnY2FudmFzJ10gOiBudWxsKS5JbWFnZSkoKTtcblxuICBsb2FkZXIuX3BlbmRpbmcgKz0gMTtcblxuICBsb2FkKHRoaXMucGFyYW1zKHVyaSksIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuICAgIGxvYWRlci5fcGVuZGluZyAtPSAxO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpbWFnZS5zcmMgPSBkYXRhO1xuICAgIGltYWdlLmxvYWRlZCA9IHRydWU7XG4gICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhudWxsLCBpbWFnZSk7XG4gIH0pO1xuXG4gIHJldHVybiBpbWFnZTtcbn1cblxucHJvdG90eXBlLmxvYWRJbWFnZSA9IGZ1bmN0aW9uKHVyaSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuIGxvYWQudXNlWEhSID9cbiAgICBicm93c2VyLmNhbGwodGhpcywgdXJpLCBjYWxsYmFjaykgOlxuICAgIHNlcnZlci5jYWxsKHRoaXMsIHVyaSwgY2FsbGJhY2spO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbWFnZUxvYWRlcjtcbiIsImZ1bmN0aW9uIEl0ZW0obWFyaykge1xuICB0aGlzLm1hcmsgPSBtYXJrO1xufVxuXG52YXIgcHJvdG90eXBlID0gSXRlbS5wcm90b3R5cGU7XG5cbnByb3RvdHlwZS5oYXNQcm9wZXJ0eVNldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5tYXJrLmRlZi5wcm9wZXJ0aWVzO1xuICByZXR1cm4gcHJvcHMgJiYgcHJvcHNbbmFtZV0gIT0gbnVsbDtcbn07XG5cbnByb3RvdHlwZS5jb3VzaW4gPSBmdW5jdGlvbihvZmZzZXQsIGluZGV4KSB7XG4gIGlmIChvZmZzZXQgPT09IDApIHJldHVybiB0aGlzO1xuICBvZmZzZXQgPSBvZmZzZXQgfHwgLTE7XG4gIHZhciBtYXJrID0gdGhpcy5tYXJrLFxuICAgICAgZ3JvdXAgPSBtYXJrLmdyb3VwLFxuICAgICAgaWlkeCA9IGluZGV4PT1udWxsID8gbWFyay5pdGVtcy5pbmRleE9mKHRoaXMpIDogaW5kZXgsXG4gICAgICBtaWR4ID0gZ3JvdXAuaXRlbXMuaW5kZXhPZihtYXJrKSArIG9mZnNldDtcbiAgcmV0dXJuIGdyb3VwLml0ZW1zW21pZHhdLml0ZW1zW2lpZHhdO1xufTtcblxucHJvdG90eXBlLnNpYmxpbmcgPSBmdW5jdGlvbihvZmZzZXQpIHtcbiAgaWYgKG9mZnNldCA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gIG9mZnNldCA9IG9mZnNldCB8fCAtMTtcbiAgdmFyIG1hcmsgPSB0aGlzLm1hcmssXG4gICAgICBpaWR4ID0gbWFyay5pdGVtcy5pbmRleE9mKHRoaXMpICsgb2Zmc2V0O1xuICByZXR1cm4gbWFyay5pdGVtc1tpaWR4XTtcbn07XG5cbnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGl0ZW0gPSB0aGlzLFxuICAgICAgbGlzdCA9IGl0ZW0ubWFyay5pdGVtcyxcbiAgICAgIGkgPSBsaXN0LmluZGV4T2YoaXRlbSk7XG4gIGlmIChpID49IDApIHtcbiAgICBpZiAoaT09PWxpc3QubGVuZ3RoLTEpIHtcbiAgICAgIGxpc3QucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXRlbTtcbn07XG5cbnByb3RvdHlwZS50b3VjaCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5wYXRoQ2FjaGUpIHRoaXMucGF0aENhY2hlID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSXRlbTsiLCJ2YXIgQm91bmRzQ29udGV4dCA9IHJlcXVpcmUoJy4vQm91bmRzQ29udGV4dCcpLFxuICAgIEJvdW5kcyA9IHJlcXVpcmUoJy4vQm91bmRzJyksXG4gICAgY2FudmFzID0gcmVxdWlyZSgnLi9jYW52YXMnKSxcbiAgICBzdmcgPSByZXF1aXJlKCcuL3N2ZycpLFxuICAgIHRleHQgPSByZXF1aXJlKCcuL3RleHQnKSxcbiAgICBwYXRocyA9IHJlcXVpcmUoJy4uL3BhdGgnKSxcbiAgICBwYXJzZSA9IHBhdGhzLnBhcnNlLFxuICAgIGRyYXdQYXRoID0gcGF0aHMucmVuZGVyLFxuICAgIGFyZWFQYXRoID0gc3ZnLnBhdGguYXJlYSxcbiAgICBsaW5lUGF0aCA9IHN2Zy5wYXRoLmxpbmUsXG4gICAgaGFsZnBpID0gTWF0aC5QSSAvIDIsXG4gICAgc3FydDMgPSBNYXRoLnNxcnQoMyksXG4gICAgdGFuMzAgPSBNYXRoLnRhbigzMCAqIE1hdGguUEkgLyAxODApLFxuICAgIGcyRCA9IG51bGwsXG4gICAgYmMgPSBCb3VuZHNDb250ZXh0KCk7XG5cbmZ1bmN0aW9uIGNvbnRleHQoKSB7XG4gIHJldHVybiBnMkQgfHwgKGcyRCA9IGNhbnZhcy5pbnN0YW5jZSgxLDEpLmdldENvbnRleHQoJzJkJykpO1xufVxuXG5mdW5jdGlvbiBzdHJva2VCb3VuZHMobywgYm91bmRzKSB7XG4gIGlmIChvLnN0cm9rZSAmJiBvLm9wYWNpdHkgIT09IDAgJiYgby5zdG9rZU9wYWNpdHkgIT09IDApIHtcbiAgICBib3VuZHMuZXhwYW5kKG8uc3Ryb2tlV2lkdGggIT0gbnVsbCA/IG8uc3Ryb2tlV2lkdGggOiAxKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG5mdW5jdGlvbiBwYXRoQm91bmRzKG8sIHBhdGgsIGJvdW5kcywgeCwgeSkge1xuICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgYm91bmRzLnNldCgwLCAwLCAwLCAwKTtcbiAgfSBlbHNlIHtcbiAgICBkcmF3UGF0aChiYy5ib3VuZHMoYm91bmRzKSwgcGF0aCwgeCwgeSk7XG4gICAgc3Ryb2tlQm91bmRzKG8sIGJvdW5kcyk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cblxuZnVuY3Rpb24gcGF0aChvLCBib3VuZHMpIHtcbiAgdmFyIHAgPSBvLnBhdGggPyBvLnBhdGhDYWNoZSB8fCAoby5wYXRoQ2FjaGUgPSBwYXJzZShvLnBhdGgpKSA6IG51bGw7XG4gIHJldHVybiBwYXRoQm91bmRzKG8sIHAsIGJvdW5kcywgby54LCBvLnkpO1xufVxuXG5mdW5jdGlvbiBhcmVhKG1hcmssIGJvdW5kcykge1xuICBpZiAobWFyay5pdGVtcy5sZW5ndGggPT09IDApIHJldHVybiBib3VuZHM7XG4gIHZhciBpdGVtcyA9IG1hcmsuaXRlbXMsXG4gICAgICBpdGVtID0gaXRlbXNbMF0sXG4gICAgICBwID0gaXRlbS5wYXRoQ2FjaGUgfHwgKGl0ZW0ucGF0aENhY2hlID0gcGFyc2UoYXJlYVBhdGgoaXRlbXMpKSk7XG4gIHJldHVybiBwYXRoQm91bmRzKGl0ZW0sIHAsIGJvdW5kcyk7XG59XG5cbmZ1bmN0aW9uIGxpbmUobWFyaywgYm91bmRzKSB7XG4gIGlmIChtYXJrLml0ZW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGJvdW5kcztcbiAgdmFyIGl0ZW1zID0gbWFyay5pdGVtcyxcbiAgICAgIGl0ZW0gPSBpdGVtc1swXSxcbiAgICAgIHAgPSBpdGVtLnBhdGhDYWNoZSB8fCAoaXRlbS5wYXRoQ2FjaGUgPSBwYXJzZShsaW5lUGF0aChpdGVtcykpKTtcbiAgcmV0dXJuIHBhdGhCb3VuZHMoaXRlbSwgcCwgYm91bmRzKTtcbn1cblxuZnVuY3Rpb24gcmVjdChvLCBib3VuZHMpIHtcbiAgdmFyIHgsIHk7XG4gIHJldHVybiBzdHJva2VCb3VuZHMobywgYm91bmRzLnNldChcbiAgICB4ID0gby54IHx8IDAsXG4gICAgeSA9IG8ueSB8fCAwLFxuICAgICh4ICsgby53aWR0aCkgfHwgMCxcbiAgICAoeSArIG8uaGVpZ2h0KSB8fCAwXG4gICkpO1xufVxuXG5mdW5jdGlvbiBpbWFnZShvLCBib3VuZHMpIHtcbiAgdmFyIHggPSBvLnggfHwgMCxcbiAgICAgIHkgPSBvLnkgfHwgMCxcbiAgICAgIHcgPSBvLndpZHRoIHx8IDAsXG4gICAgICBoID0gby5oZWlnaHQgfHwgMDtcbiAgeCA9IHggLSAoby5hbGlnbiA9PT0gJ2NlbnRlcicgPyB3LzIgOiAoby5hbGlnbiA9PT0gJ3JpZ2h0JyA/IHcgOiAwKSk7XG4gIHkgPSB5IC0gKG8uYmFzZWxpbmUgPT09ICdtaWRkbGUnID8gaC8yIDogKG8uYmFzZWxpbmUgPT09ICdib3R0b20nID8gaCA6IDApKTtcbiAgcmV0dXJuIGJvdW5kcy5zZXQoeCwgeSwgeCt3LCB5K2gpO1xufVxuXG5mdW5jdGlvbiBydWxlKG8sIGJvdW5kcykge1xuICB2YXIgeDEsIHkxO1xuICByZXR1cm4gc3Ryb2tlQm91bmRzKG8sIGJvdW5kcy5zZXQoXG4gICAgeDEgPSBvLnggfHwgMCxcbiAgICB5MSA9IG8ueSB8fCAwLFxuICAgIG8ueDIgIT0gbnVsbCA/IG8ueDIgOiB4MSxcbiAgICBvLnkyICE9IG51bGwgPyBvLnkyIDogeTFcbiAgKSk7XG59XG5cbmZ1bmN0aW9uIGFyYyhvLCBib3VuZHMpIHtcbiAgdmFyIGN4ID0gby54IHx8IDAsXG4gICAgICBjeSA9IG8ueSB8fCAwLFxuICAgICAgaXIgPSBvLmlubmVyUmFkaXVzIHx8IDAsXG4gICAgICBvciA9IG8ub3V0ZXJSYWRpdXMgfHwgMCxcbiAgICAgIHNhID0gKG8uc3RhcnRBbmdsZSB8fCAwKSAtIGhhbGZwaSxcbiAgICAgIGVhID0gKG8uZW5kQW5nbGUgfHwgMCkgLSBoYWxmcGksXG4gICAgICB4bWluID0gSW5maW5pdHksIHhtYXggPSAtSW5maW5pdHksXG4gICAgICB5bWluID0gSW5maW5pdHksIHltYXggPSAtSW5maW5pdHksXG4gICAgICBhLCBpLCBuLCB4LCB5LCBpeCwgaXksIG94LCBveTtcblxuICB2YXIgYW5nbGVzID0gW3NhLCBlYV0sXG4gICAgICBzID0gc2EgLSAoc2EgJSBoYWxmcGkpO1xuICBmb3IgKGk9MDsgaTw0ICYmIHM8ZWE7ICsraSwgcys9aGFsZnBpKSB7XG4gICAgYW5nbGVzLnB1c2gocyk7XG4gIH1cblxuICBmb3IgKGk9MCwgbj1hbmdsZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIGEgPSBhbmdsZXNbaV07XG4gICAgeCA9IE1hdGguY29zKGEpOyBpeCA9IGlyKng7IG94ID0gb3IqeDtcbiAgICB5ID0gTWF0aC5zaW4oYSk7IGl5ID0gaXIqeTsgb3kgPSBvcip5O1xuICAgIHhtaW4gPSBNYXRoLm1pbih4bWluLCBpeCwgb3gpO1xuICAgIHhtYXggPSBNYXRoLm1heCh4bWF4LCBpeCwgb3gpO1xuICAgIHltaW4gPSBNYXRoLm1pbih5bWluLCBpeSwgb3kpO1xuICAgIHltYXggPSBNYXRoLm1heCh5bWF4LCBpeSwgb3kpO1xuICB9XG5cbiAgcmV0dXJuIHN0cm9rZUJvdW5kcyhvLCBib3VuZHMuc2V0KFxuICAgIGN4ICsgeG1pbixcbiAgICBjeSArIHltaW4sXG4gICAgY3ggKyB4bWF4LFxuICAgIGN5ICsgeW1heFxuICApKTtcbn1cblxuZnVuY3Rpb24gc3ltYm9sKG8sIGJvdW5kcykge1xuICB2YXIgc2l6ZSA9IG8uc2l6ZSAhPSBudWxsID8gby5zaXplIDogMTAwLFxuICAgICAgeCA9IG8ueCB8fCAwLFxuICAgICAgeSA9IG8ueSB8fCAwLFxuICAgICAgciwgdCwgcngsIHJ5O1xuXG4gIHN3aXRjaCAoby5zaGFwZSkge1xuICAgIGNhc2UgJ2Nyb3NzJzpcbiAgICAgIHQgPSAzICogTWF0aC5zcXJ0KHNpemUgLyA1KSAvIDI7XG4gICAgICBib3VuZHMuc2V0KHgtdCwgeS10LCB4K3QsIHkrdCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2RpYW1vbmQnOlxuICAgICAgcnkgPSBNYXRoLnNxcnQoc2l6ZSAvICgyICogdGFuMzApKTtcbiAgICAgIHJ4ID0gcnkgKiB0YW4zMDtcbiAgICAgIGJvdW5kcy5zZXQoeC1yeCwgeS1yeSwgeCtyeCwgeStyeSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3NxdWFyZSc6XG4gICAgICB0ID0gTWF0aC5zcXJ0KHNpemUpO1xuICAgICAgciA9IHQgLyAyO1xuICAgICAgYm91bmRzLnNldCh4LXIsIHktciwgeCtyLCB5K3IpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0cmlhbmdsZS1kb3duJzpcbiAgICAgIHJ4ID0gTWF0aC5zcXJ0KHNpemUgLyBzcXJ0Myk7XG4gICAgICByeSA9IHJ4ICogc3FydDMgLyAyO1xuICAgICAgYm91bmRzLnNldCh4LXJ4LCB5LXJ5LCB4K3J4LCB5K3J5KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndHJpYW5nbGUtdXAnOlxuICAgICAgcnggPSBNYXRoLnNxcnQoc2l6ZSAvIHNxcnQzKTtcbiAgICAgIHJ5ID0gcnggKiBzcXJ0MyAvIDI7XG4gICAgICBib3VuZHMuc2V0KHgtcngsIHktcnksIHgrcngsIHkrcnkpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgciA9IE1hdGguc3FydChzaXplL01hdGguUEkpO1xuICAgICAgYm91bmRzLnNldCh4LXIsIHktciwgeCtyLCB5K3IpO1xuICB9XG5cbiAgcmV0dXJuIHN0cm9rZUJvdW5kcyhvLCBib3VuZHMpO1xufVxuXG5mdW5jdGlvbiB0ZXh0TWFyayhvLCBib3VuZHMsIG5vUm90YXRlKSB7XG4gIHZhciBnID0gY29udGV4dCgpLFxuICAgICAgaCA9IHRleHQuc2l6ZShvKSxcbiAgICAgIGEgPSBvLmFsaWduLFxuICAgICAgciA9IG8ucmFkaXVzIHx8IDAsXG4gICAgICB4ID0gKG8ueCB8fCAwKSxcbiAgICAgIHkgPSAoby55IHx8IDApLFxuICAgICAgZHggPSAoby5keCB8fCAwKSxcbiAgICAgIGR5ID0gKG8uZHkgfHwgMCkgKyB0ZXh0Lm9mZnNldChvKSAtIE1hdGgucm91bmQoMC44KmgpLCAvLyB1c2UgNC81IG9mZnNldFxuICAgICAgdywgdDtcblxuICBpZiAocikge1xuICAgIHQgPSAoby50aGV0YSB8fCAwKSAtIE1hdGguUEkvMjtcbiAgICB4ICs9IHIgKiBNYXRoLmNvcyh0KTtcbiAgICB5ICs9IHIgKiBNYXRoLnNpbih0KTtcbiAgfVxuXG4gIC8vIGhvcml6b250YWwgYWxpZ25tZW50XG4gIGcuZm9udCA9IHRleHQuZm9udChvKTtcbiAgdyA9IGcubWVhc3VyZVRleHQodGV4dC52YWx1ZShvLnRleHQpKS53aWR0aDtcbiAgaWYgKGEgPT09ICdjZW50ZXInKSB7XG4gICAgZHggLT0gKHcgLyAyKTtcbiAgfSBlbHNlIGlmIChhID09PSAncmlnaHQnKSB7XG4gICAgZHggLT0gdztcbiAgfSBlbHNlIHtcbiAgICAvLyBsZWZ0IGJ5IGRlZmF1bHQsIGRvIG5vdGhpbmdcbiAgfVxuXG4gIGJvdW5kcy5zZXQoZHgrPXgsIGR5Kz15LCBkeCt3LCBkeStoKTtcbiAgaWYgKG8uYW5nbGUgJiYgIW5vUm90YXRlKSB7XG4gICAgYm91bmRzLnJvdGF0ZShvLmFuZ2xlKk1hdGguUEkvMTgwLCB4LCB5KTtcbiAgfVxuICByZXR1cm4gYm91bmRzLmV4cGFuZChub1JvdGF0ZSA/IDAgOiAxKTtcbn1cblxuZnVuY3Rpb24gZ3JvdXAoZywgYm91bmRzLCBpbmNsdWRlTGVnZW5kcykge1xuICB2YXIgYXhlcyA9IGcuYXhpc0l0ZW1zIHx8IFtdLFxuICAgICAgaXRlbXMgPSBnLml0ZW1zIHx8IFtdLFxuICAgICAgbGVnZW5kcyA9IGcubGVnZW5kSXRlbXMgfHwgW10sXG4gICAgICBqLCBtO1xuXG4gIGlmICghZy5jbGlwKSB7XG4gICAgZm9yIChqPTAsIG09YXhlcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBib3VuZHMudW5pb24oYXhlc1tqXS5ib3VuZHMpO1xuICAgIH1cbiAgICBmb3IgKGo9MCwgbT1pdGVtcy5sZW5ndGg7IGo8bTsgKytqKSB7XG4gICAgICBib3VuZHMudW5pb24oaXRlbXNbal0uYm91bmRzKTtcbiAgICB9XG4gICAgaWYgKGluY2x1ZGVMZWdlbmRzKSB7XG4gICAgICBmb3IgKGo9MCwgbT1sZWdlbmRzLmxlbmd0aDsgajxtOyArK2opIHtcbiAgICAgICAgYm91bmRzLnVuaW9uKGxlZ2VuZHNbal0uYm91bmRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGcuY2xpcCB8fCBnLndpZHRoIHx8IGcuaGVpZ2h0KSB7XG4gICAgc3Ryb2tlQm91bmRzKGcsIGJvdW5kc1xuICAgICAgLmFkZCgwLCAwKVxuICAgICAgLmFkZChnLndpZHRoIHx8IDAsIGcuaGVpZ2h0IHx8IDApKTtcbiAgfVxuICByZXR1cm4gYm91bmRzLnRyYW5zbGF0ZShnLnggfHwgMCwgZy55IHx8IDApO1xufVxuXG52YXIgbWV0aG9kcyA9IHtcbiAgZ3JvdXA6ICBncm91cCxcbiAgc3ltYm9sOiBzeW1ib2wsXG4gIGltYWdlOiAgaW1hZ2UsXG4gIHJlY3Q6ICAgcmVjdCxcbiAgcnVsZTogICBydWxlLFxuICBhcmM6ICAgIGFyYyxcbiAgdGV4dDogICB0ZXh0TWFyayxcbiAgcGF0aDogICBwYXRoLFxuICBhcmVhOiAgIGFyZWEsXG4gIGxpbmU6ICAgbGluZVxufTtcbm1ldGhvZHMuYXJlYS5uZXN0ID0gdHJ1ZTtcbm1ldGhvZHMubGluZS5uZXN0ID0gdHJ1ZTtcblxuZnVuY3Rpb24gaXRlbUJvdW5kcyhpdGVtLCBmdW5jLCBvcHQpIHtcbiAgdmFyIHR5cGUgPSBpdGVtLm1hcmsubWFya3R5cGU7XG4gIGZ1bmMgPSBmdW5jIHx8IG1ldGhvZHNbdHlwZV07XG4gIGlmIChmdW5jLm5lc3QpIGl0ZW0gPSBpdGVtLm1hcms7XG5cbiAgdmFyIGN1cnIgPSBpdGVtLmJvdW5kcyxcbiAgICAgIHByZXYgPSBpdGVtWydib3VuZHM6cHJldiddIHx8IChpdGVtWydib3VuZHM6cHJldiddID0gbmV3IEJvdW5kcygpKTtcblxuICBpZiAoY3Vycikge1xuICAgIHByZXYuY2xlYXIoKS51bmlvbihjdXJyKTtcbiAgICBjdXJyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbS5ib3VuZHMgPSBuZXcgQm91bmRzKCk7XG4gIH1cbiAgZnVuYyhpdGVtLCBpdGVtLmJvdW5kcywgb3B0KTtcbiAgaWYgKCFjdXJyKSBwcmV2LmNsZWFyKCkudW5pb24oaXRlbS5ib3VuZHMpO1xuICByZXR1cm4gaXRlbS5ib3VuZHM7XG59XG5cbnZhciBEVU1NWV9JVEVNID0ge21hcms6IG51bGx9O1xuXG5mdW5jdGlvbiBtYXJrQm91bmRzKG1hcmssIGJvdW5kcywgb3B0KSB7XG4gIHZhciB0eXBlICA9IG1hcmsubWFya3R5cGUsXG4gICAgICBmdW5jICA9IG1ldGhvZHNbdHlwZV0sXG4gICAgICBpdGVtcyA9IG1hcmsuaXRlbXMsXG4gICAgICBoYXNpICA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCxcbiAgICAgIGksIG4sIG8sIGI7XG5cbiAgaWYgKGZ1bmMubmVzdCkge1xuICAgIG8gPSBoYXNpID8gaXRlbXNbMF1cbiAgICAgIDogKERVTU1ZX0lURU0ubWFyayA9IG1hcmssIERVTU1ZX0lURU0pOyAvLyBubyBpdGVtcywgc28gZmFrZSBpdFxuICAgIGIgPSBpdGVtQm91bmRzKG8sIGZ1bmMsIG9wdCk7XG4gICAgYm91bmRzID0gYm91bmRzICYmIGJvdW5kcy51bmlvbihiKSB8fCBiO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cblxuICBib3VuZHMgPSBib3VuZHMgfHwgbWFyay5ib3VuZHMgJiYgbWFyay5ib3VuZHMuY2xlYXIoKSB8fCBuZXcgQm91bmRzKCk7XG4gIGlmIChoYXNpKSB7ICBcbiAgICBmb3IgKGk9MCwgbj1pdGVtcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICBib3VuZHMudW5pb24oaXRlbUJvdW5kcyhpdGVtc1tpXSwgZnVuYywgb3B0KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiAobWFyay5ib3VuZHMgPSBib3VuZHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbWFyazogIG1hcmtCb3VuZHMsXG4gIGl0ZW06ICBpdGVtQm91bmRzLFxuICB0ZXh0OiAgdGV4dE1hcmssXG4gIGdyb3VwOiBncm91cFxufTtcbiIsImZ1bmN0aW9uIGluc3RhbmNlKHcsIGgpIHtcbiAgdyA9IHcgfHwgMTtcbiAgaCA9IGggfHwgMTtcbiAgdmFyIGNhbnZhcztcblxuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KSB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gdztcbiAgICBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgQ2FudmFzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ2NhbnZhcyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnY2FudmFzJ10gOiBudWxsKTtcbiAgICBpZiAoIUNhbnZhcy5wcm90b3R5cGUpIHJldHVybiBudWxsO1xuICAgIGNhbnZhcyA9IG5ldyBDYW52YXModywgaCk7XG4gIH1cbiAgcmV0dXJuIGxpbmVEYXNoKGNhbnZhcyk7XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZShjYW52YXMsIHcsIGgsIHAsIHJldGluYSkge1xuICB2YXIgZyA9IHRoaXMuX2N0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLCBcbiAgICAgIHMgPSAxO1xuXG4gIGNhbnZhcy53aWR0aCA9IHcgKyBwLmxlZnQgKyBwLnJpZ2h0O1xuICBjYW52YXMuaGVpZ2h0ID0gaCArIHAudG9wICsgcC5ib3R0b207XG5cbiAgLy8gaWYgYnJvd3NlciBjYW52YXMsIGF0dGVtcHQgdG8gbW9kaWZ5IGZvciByZXRpbmEgZGlzcGxheVxuICBpZiAocmV0aW5hICYmIHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxuICB7XG4gICAgZy5waXhlbHJhdGlvID0gKHMgPSBwaXhlbFJhdGlvKGNhbnZhcykgfHwgMSk7XG4gIH1cblxuICBnLnNldFRyYW5zZm9ybShzLCAwLCAwLCBzLCBzKnAubGVmdCwgcypwLnRvcCk7XG4gIHJldHVybiBjYW52YXM7XG59XG5cbmZ1bmN0aW9uIHBpeGVsUmF0aW8oY2FudmFzKSB7XG4gIHZhciBnID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgLy8gZ2V0IGNhbnZhcyBwaXhlbCBkYXRhXG4gIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93ICYmIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG4gICAgICBiYWNraW5nU3RvcmVSYXRpbyA9IChcbiAgICAgICAgZy53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGcubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBnLm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICBnLm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgIGcuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbykgfHwgMSxcbiAgICAgIHJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuXG4gIGlmIChkZXZpY2VQaXhlbFJhdGlvICE9PSBiYWNraW5nU3RvcmVSYXRpbykge1xuICAgIC8vIHNldCBhY3R1YWwgYW5kIHZpc2libGUgY2FudmFzIHNpemVcbiAgICB2YXIgdyA9IGNhbnZhcy53aWR0aCxcbiAgICAgICAgaCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gdyAqIHJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoICogcmF0aW87XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gdyArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGggKyAncHgnO1xuICB9XG5cbiAgcmV0dXJuIHJhdGlvO1xufVxuXG5mdW5jdGlvbiBsaW5lRGFzaChjYW52YXMpIHtcbiAgdmFyIGcgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgaWYgKGcudmdMaW5lRGFzaCkgcmV0dXJuOyAvLyBhbHJlYWR5IGluaXRpYWxpemVkIVxuXG4gIHZhciBOT09QID0gZnVuY3Rpb24oKSB7fSxcbiAgICAgIE5PREFTSCA9IFtdO1xuICBcbiAgaWYgKGcuc2V0TGluZURhc2gpIHtcbiAgICBnLnZnTGluZURhc2ggPSBmdW5jdGlvbihkYXNoKSB7IHRoaXMuc2V0TGluZURhc2goZGFzaCB8fCBOT0RBU0gpOyB9O1xuICAgIGcudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gb2ZmOyB9O1xuICB9IGVsc2UgaWYgKGcud2Via2l0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICBcdGcudmdMaW5lRGFzaCA9IGZ1bmN0aW9uKGRhc2gpIHsgdGhpcy53ZWJraXRMaW5lRGFzaCA9IGRhc2ggfHwgTk9EQVNIOyB9O1xuICAgIGcudmdMaW5lRGFzaE9mZnNldCA9IGZ1bmN0aW9uKG9mZikgeyB0aGlzLndlYmtpdExpbmVEYXNoT2Zmc2V0ID0gb2ZmOyB9O1xuICB9IGVsc2UgaWYgKGcubW96RGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZy52Z0xpbmVEYXNoID0gZnVuY3Rpb24oZGFzaCkgeyB0aGlzLm1vekRhc2ggPSBkYXNoOyB9O1xuICAgIGcudmdMaW5lRGFzaE9mZnNldCA9IE5PT1A7XG4gIH0gZWxzZSB7XG4gICAgZy52Z0xpbmVEYXNoID0gTk9PUDtcbiAgICBnLnZnTGluZURhc2hPZmZzZXQgPSBOT09QO1xuICB9XG4gIHJldHVybiBjYW52YXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbnN0YW5jZTogICBpbnN0YW5jZSxcbiAgcmVzaXplOiAgICAgcmVzaXplLFxuICBsaW5lRGFzaDogICBsaW5lRGFzaFxufTtcbiIsIi8vIGNyZWF0ZSBhIG5ldyBET00gZWxlbWVudFxuZnVuY3Rpb24gY3JlYXRlKGRvYywgdGFnLCBucykge1xuICByZXR1cm4gbnMgPyBkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnKTtcbn1cblxuLy8gcmVtb3ZlIGVsZW1lbnQgZnJvbSBET01cbi8vIHJlY3Vyc2l2ZWx5IHJlbW92ZSBwYXJlbnQgZWxlbWVudHMgaWYgZW1wdHlcbmZ1bmN0aW9uIHJlbW92ZShlbCkge1xuICBpZiAoIWVsKSByZXR1cm47XG4gIHZhciBwID0gZWwucGFyZW50Tm9kZTtcbiAgaWYgKHApIHtcbiAgICBwLnJlbW92ZUNoaWxkKGVsKTtcbiAgICBpZiAoIXAuY2hpbGROb2RlcyB8fCAhcC5jaGlsZE5vZGVzLmxlbmd0aCkgcmVtb3ZlKHApO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBmaW5kIGZpcnN0IGNoaWxkIGVsZW1lbnQgd2l0aCBtYXRjaGluZyB0YWdcbiAgZmluZDogZnVuY3Rpb24oZWwsIHRhZykge1xuICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgIGZvciAodmFyIGk9MCwgbj1lbC5jaGlsZE5vZGVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGlmIChlbC5jaGlsZE5vZGVzW2ldLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnKSB7XG4gICAgICAgIHJldHVybiBlbC5jaGlsZE5vZGVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gcmV0cmlldmUgY2hpbGQgZWxlbWVudCBhdCBnaXZlbiBpbmRleFxuICAvLyBjcmVhdGUgJiBpbnNlcnQgaWYgZG9lc24ndCBleGlzdCBvciBpZiB0YWcvY2xhc3NOYW1lIGRvIG5vdCBtYXRjaFxuICBjaGlsZDogZnVuY3Rpb24oZWwsIGluZGV4LCB0YWcsIG5zLCBjbGFzc05hbWUsIGluc2VydCkge1xuICAgIHZhciBhLCBiO1xuICAgIGEgPSBiID0gZWwuY2hpbGROb2Rlc1tpbmRleF07XG4gICAgaWYgKCFhIHx8IGluc2VydCB8fFxuICAgICAgICBhLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gdGFnLnRvTG93ZXJDYXNlKCkgfHxcbiAgICAgICAgY2xhc3NOYW1lICYmIGEuZ2V0QXR0cmlidXRlKCdjbGFzcycpICE9IGNsYXNzTmFtZSkge1xuICAgICAgYSA9IGNyZWF0ZShlbC5vd25lckRvY3VtZW50LCB0YWcsIG5zKTtcbiAgICAgIGVsLmluc2VydEJlZm9yZShhLCBiKTtcbiAgICAgIGlmIChjbGFzc05hbWUpIGEuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9LFxuICAvLyByZW1vdmUgYWxsIGNoaWxkIGVsZW1lbnRzIGF0IG9yIGFib3ZlIHRoZSBnaXZlbiBpbmRleFxuICBjbGVhcjogZnVuY3Rpb24oZWwsIGluZGV4KSB7XG4gICAgdmFyIGN1cnIgPSBlbC5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB3aGlsZSAoY3VyciA+IGluZGV4KSB7XG4gICAgICBlbC5yZW1vdmVDaGlsZChlbC5jaGlsZE5vZGVzWy0tY3Vycl0pO1xuICAgIH1cbiAgICByZXR1cm4gZWw7XG4gIH0sXG4gIHJlbW92ZTogcmVtb3ZlLFxuICAvLyBnZW5lcmF0ZSBjc3MgY2xhc3MgbmFtZSBmb3IgbWFya1xuICBjc3NDbGFzczogZnVuY3Rpb24obWFyaykge1xuICAgIHJldHVybiAnbWFyay0nICsgbWFyay5tYXJrdHlwZSArIChtYXJrLm5hbWUgPyAnICcrbWFyay5uYW1lIDogJycpO1xuICB9LFxuICAvLyBnZW5lcmF0ZSBzdHJpbmcgZm9yIGFuIG9wZW5pbmcgeG1sIHRhZ1xuICAvLyB0YWc6IHRoZSBuYW1lIG9mIHRoZSB4bWwgdGFnXG4gIC8vIGF0dHI6IGhhc2ggb2YgYXR0cmlidXRlIG5hbWUtdmFsdWUgcGFpcnMgdG8gaW5jbHVkZVxuICAvLyByYXc6IGFkZGl0aW9uYWwgcmF3IHN0cmluZyB0byBpbmNsdWRlIGluIHRhZyBtYXJrdXBcbiAgb3BlblRhZzogZnVuY3Rpb24odGFnLCBhdHRyLCByYXcpIHtcbiAgICB2YXIgcyA9ICc8JyArIHRhZywga2V5LCB2YWw7XG4gICAgaWYgKGF0dHIpIHtcbiAgICAgIGZvciAoa2V5IGluIGF0dHIpIHtcbiAgICAgICAgdmFsID0gYXR0cltrZXldO1xuICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcbiAgICAgICAgICBzICs9ICcgJyArIGtleSArICc9XCInICsgdmFsICsgJ1wiJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmF3KSBzICs9ICcgJyArIHJhdztcbiAgICByZXR1cm4gcyArICc+JztcbiAgfSxcbiAgLy8gZ2VuZXJhdGUgc3RyaW5nIGZvciBjbG9zaW5nIHhtbCB0YWdcbiAgLy8gdGFnOiB0aGUgbmFtZSBvZiB0aGUgeG1sIHRhZ1xuICBjbG9zZVRhZzogZnVuY3Rpb24odGFnKSB7XG4gICAgcmV0dXJuICc8LycgKyB0YWcgKyAnPic7XG4gIH1cbn07XG4iLCJ2YXIgYm91bmQgPSByZXF1aXJlKCcuLi91dGlsL2JvdW5kJyk7XG5cbnZhciBzZXRzID0gW1xuICAnaXRlbXMnLFxuICAnYXhpc0l0ZW1zJyxcbiAgJ2xlZ2VuZEl0ZW1zJ1xuXTtcblxudmFyIGtleXMgPSBbXG4gICdtYXJrdHlwZScsICduYW1lJywgJ2ludGVyYWN0aXZlJywgJ2NsaXAnLFxuICAnaXRlbXMnLCAnYXhpc0l0ZW1zJywgJ2xlZ2VuZEl0ZW1zJywgJ2xheWVyJyxcbiAgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnYWxpZ24nLCAnYmFzZWxpbmUnLCAgICAgICAgICAgICAvLyBsYXlvdXRcbiAgJ2ZpbGwnLCAnZmlsbE9wYWNpdHknLCAnb3BhY2l0eScsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmaWxsXG4gICdzdHJva2UnLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VXaWR0aCcsICdzdHJva2VDYXAnLCAgICAgICAgLy8gc3Ryb2tlXG4gICdzdHJva2VEYXNoJywgJ3N0cm9rZURhc2hPZmZzZXQnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Ryb2tlIGRhc2hcbiAgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAgICAgICAvLyBhcmNcbiAgJ2ludGVycG9sYXRlJywgJ3RlbnNpb24nLCAnb3JpZW50JywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmVhLCBsaW5lXG4gICd1cmwnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW1hZ2VcbiAgJ3BhdGgnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwYXRoXG4gICd4MicsICd5MicsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcnVsZVxuICAnc2l6ZScsICdzaGFwZScsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN5bWJvbFxuICAndGV4dCcsICdhbmdsZScsICd0aGV0YScsICdyYWRpdXMnLCAnZHgnLCAnZHknLCAgICAgICAgICAgICAgIC8vIHRleHRcbiAgJ2ZvbnQnLCAnZm9udFNpemUnLCAnZm9udFdlaWdodCcsICdmb250U3R5bGUnLCAnZm9udFZhcmlhbnQnICAvLyBmb250XG5dO1xuXG5mdW5jdGlvbiB0b0pTT04oc2NlbmUsIGluZGVudCkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc2NlbmUsIGtleXMsIGluZGVudCk7XG59XG5cbmZ1bmN0aW9uIGZyb21KU09OKGpzb24pIHtcbiAgdmFyIHNjZW5lID0gKHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uKTtcbiAgcmV0dXJuIGluaXRpYWxpemUoc2NlbmUpO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplKHNjZW5lKSB7XG4gIHZhciB0eXBlID0gc2NlbmUubWFya3R5cGUsXG4gICAgICBpLCBuLCBzLCBtLCBpdGVtcztcblxuICBmb3IgKHM9MCwgbT1zZXRzLmxlbmd0aDsgczxtOyArK3MpIHtcbiAgICBpZiAoKGl0ZW1zID0gc2NlbmVbc2V0c1tzXV0pKSB7XG4gICAgICBmb3IgKGk9MCwgbj1pdGVtcy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgICAgIGl0ZW1zW2ldW3R5cGUgPyAnbWFyaycgOiAnZ3JvdXAnXSA9IHNjZW5lO1xuICAgICAgICBpZiAoIXR5cGUgfHwgdHlwZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICAgIGluaXRpYWxpemUoaXRlbXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUpIGJvdW5kLm1hcmsoc2NlbmUpO1xuICByZXR1cm4gc2NlbmU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0b0pTT046ICAgdG9KU09OLFxuICBmcm9tSlNPTjogZnJvbUpTT05cbn07IiwidmFyIGQzX3N2ZyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93WydkMyddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsnZDMnXSA6IG51bGwpLnN2ZztcblxuZnVuY3Rpb24geChvKSAgICAgeyByZXR1cm4gby54IHx8IDA7IH1cbmZ1bmN0aW9uIHkobykgICAgIHsgcmV0dXJuIG8ueSB8fCAwOyB9XG5mdW5jdGlvbiB4dyhvKSAgICB7IHJldHVybiAoby54IHx8IDApICsgKG8ud2lkdGggfHwgMCk7IH1cbmZ1bmN0aW9uIHloKG8pICAgIHsgcmV0dXJuIChvLnkgfHwgMCkgKyAoby5oZWlnaHQgfHwgMCk7IH1cbmZ1bmN0aW9uIHNpemUobykgIHsgcmV0dXJuIG8uc2l6ZSA9PSBudWxsID8gMTAwIDogby5zaXplOyB9XG5mdW5jdGlvbiBzaGFwZShvKSB7IHJldHVybiBvLnNoYXBlIHx8ICdjaXJjbGUnOyB9XG5cbnZhciBhcmVhdiA9IGQzX3N2Zy5hcmVhKCkueCh4KS55MSh5KS55MCh5aCksXG4gICAgYXJlYWggPSBkM19zdmcuYXJlYSgpLnkoeSkueDEoeCkueDAoeHcpLFxuICAgIGxpbmUgID0gZDNfc3ZnLmxpbmUoKS54KHgpLnkoeSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBtZXRhZGF0YToge1xuICAgICd2ZXJzaW9uJzogJzEuMScsXG4gICAgJ3htbG5zJzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICAneG1sbnM6eGxpbmsnOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcbiAgfSxcbiAgcGF0aDoge1xuICAgIGFyYzogZDNfc3ZnLmFyYygpLFxuICAgIHN5bWJvbDogZDNfc3ZnLnN5bWJvbCgpLnR5cGUoc2hhcGUpLnNpemUoc2l6ZSksXG4gICAgYXJlYTogZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgIHZhciBvID0gaXRlbXNbMF07XG4gICAgICByZXR1cm4gKG8ub3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBhcmVhaCA6IGFyZWF2KVxuICAgICAgICAuaW50ZXJwb2xhdGUoby5pbnRlcnBvbGF0ZSB8fCAnbGluZWFyJylcbiAgICAgICAgLnRlbnNpb24oby50ZW5zaW9uIHx8IDAuNylcbiAgICAgICAgKGl0ZW1zKTtcbiAgICB9LFxuICAgIGxpbmU6IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICB2YXIgbyA9IGl0ZW1zWzBdO1xuICAgICAgcmV0dXJuIGxpbmVcbiAgICAgICAgLmludGVycG9sYXRlKG8uaW50ZXJwb2xhdGUgfHwgJ2xpbmVhcicpXG4gICAgICAgIC50ZW5zaW9uKG8udGVuc2lvbiB8fCAwLjcpXG4gICAgICAgIChpdGVtcyk7XG4gICAgfVxuICB9LFxuICB0ZXh0QWxpZ246IHtcbiAgICAnbGVmdCc6ICAgJ3N0YXJ0JyxcbiAgICAnY2VudGVyJzogJ21pZGRsZScsXG4gICAgJ3JpZ2h0JzogICdlbmQnXG4gIH0sXG4gIHRleHRCYXNlbGluZToge1xuICAgICd0b3AnOiAgICAnYmVmb3JlLWVkZ2UnLFxuICAgICdib3R0b20nOiAnYWZ0ZXItZWRnZScsXG4gICAgJ21pZGRsZSc6ICdjZW50cmFsJ1xuICB9LFxuICBzdHlsZXM6IHtcbiAgICAnZmlsbCc6ICAgICAgICAgICAgICdmaWxsJyxcbiAgICAnZmlsbE9wYWNpdHknOiAgICAgICdmaWxsLW9wYWNpdHknLFxuICAgICdzdHJva2UnOiAgICAgICAgICAgJ3N0cm9rZScsXG4gICAgJ3N0cm9rZVdpZHRoJzogICAgICAnc3Ryb2tlLXdpZHRoJyxcbiAgICAnc3Ryb2tlT3BhY2l0eSc6ICAgICdzdHJva2Utb3BhY2l0eScsXG4gICAgJ3N0cm9rZUNhcCc6ICAgICAgICAnc3Ryb2tlLWxpbmVjYXAnLFxuICAgICdzdHJva2VEYXNoJzogICAgICAgJ3N0cm9rZS1kYXNoYXJyYXknLFxuICAgICdzdHJva2VEYXNoT2Zmc2V0JzogJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgICAnb3BhY2l0eSc6ICAgICAgICAgICdvcGFjaXR5J1xuICB9LFxuICBzdHlsZVByb3BlcnRpZXM6IFtcbiAgICAnZmlsbCcsXG4gICAgJ2ZpbGxPcGFjaXR5JyxcbiAgICAnc3Ryb2tlJyxcbiAgICAnc3Ryb2tlV2lkdGgnLFxuICAgICdzdHJva2VPcGFjaXR5JyxcbiAgICAnc3Ryb2tlQ2FwJyxcbiAgICAnc3Ryb2tlRGFzaCcsXG4gICAgJ3N0cm9rZURhc2hPZmZzZXQnLFxuICAgICdvcGFjaXR5J1xuICBdXG59O1xuIiwiZnVuY3Rpb24gc2l6ZShpdGVtKSB7XG4gIHJldHVybiBpdGVtLmZvbnRTaXplICE9IG51bGwgPyBpdGVtLmZvbnRTaXplIDogMTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBzaXplOiBzaXplLFxuICB2YWx1ZTogZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBzICE9IG51bGwgPyBTdHJpbmcocykgOiAnJztcbiAgfSxcbiAgZm9udDogZnVuY3Rpb24oaXRlbSwgcXVvdGUpIHtcbiAgICB2YXIgZm9udCA9IGl0ZW0uZm9udDtcbiAgICBpZiAocXVvdGUgJiYgZm9udCkge1xuICAgICAgZm9udCA9IFN0cmluZyhmb250KS5yZXBsYWNlKC9cXFwiL2csICdcXCcnKTtcbiAgICB9XG4gICAgcmV0dXJuICcnICtcbiAgICAgIChpdGVtLmZvbnRTdHlsZSA/IGl0ZW0uZm9udFN0eWxlICsgJyAnIDogJycpICtcbiAgICAgIChpdGVtLmZvbnRWYXJpYW50ID8gaXRlbS5mb250VmFyaWFudCArICcgJyA6ICcnKSArXG4gICAgICAoaXRlbS5mb250V2VpZ2h0ID8gaXRlbS5mb250V2VpZ2h0ICsgJyAnIDogJycpICtcbiAgICAgIHNpemUoaXRlbSkgKyAncHggJyArXG4gICAgICAoZm9udCB8fCAnc2Fucy1zZXJpZicpO1xuICB9LFxuICBvZmZzZXQ6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAvLyBwZXJmb3JtIG91ciBvd24gZm9udCBiYXNlbGluZSBjYWxjdWxhdGlvblxuICAgIC8vIHdoeT8gbm90IGFsbCBicm93c2VycyBzdXBwb3J0IFNWRyAxLjEgJ2FsaWdubWVudC1iYXNlbGluZScgOihcbiAgICB2YXIgYmFzZWxpbmUgPSBpdGVtLmJhc2VsaW5lLFxuICAgICAgICBoID0gc2l6ZShpdGVtKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChcbiAgICAgIGJhc2VsaW5lID09PSAndG9wJyAgICA/ICAwLjkzKmggOlxuICAgICAgYmFzZWxpbmUgPT09ICdtaWRkbGUnID8gIDAuMzAqaCA6XG4gICAgICBiYXNlbGluZSA9PT0gJ2JvdHRvbScgPyAtMC4yMSpoIDogMFxuICAgICk7XG4gIH1cbn07XG4iXX0=
